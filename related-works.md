# 操作系统调试器相关工作

## 概述

在调试操作系统时，有两类调试工具比较有用。第一类是支持单步断点调试的源代码级调试工具，比如KGDB（可以跟踪boot-time，但是要修改编译参数/源代码）。第二类是不支持单步的调试信息获取工具。

在调试操作系统时，我们可以使用如下几类工具：

- debuggers (KDB and KGDB),
- dumping while crashed (LKCD),
- tracing toolkit (LTT, LTTV, and LTTng),
- custom kernel instruments (dprobes and kprobes).

### LKCD

The LKCD (Linux Kernel Crash Dump) tool allows the Linux system to write the contents of its memory when a crash occurs.

### OOPS

Oops: when the kernel detects a problem, it prints an Oops message. Such a message is generated by printk statements in the fault handler (arch/*/kernel/traps.c). A dedicated ring buffer in the kernel is being used by the printk statements. Oops contains information like the CPU where the Oops occurred on, contents of CPU registers, number of Oops, description, stack back trace and others. Resources regarding kernel Oops:

### Dynamic Probes

Dynamic Probes is one of the popular debugging tool for Linux which developed by IBM. This tool allows the placement of a “probe” at almost any place in the system, in both user and kernel space. The probe consists of some code (written in a specialized, stack-oriented language) that is executed when control hits the given point.

### Linux Trace Tookit

Linux Trace Toolkit **is a kernel patch** and a set of related utilities that allow the tracing of events in the kernel. The trace includes timing information and can create a reasonably complete picture of what happened over a given period of time. Resources of LTT, LTT Viewer and LTT Next Generation

简单来说：要改代码

### MEMWATCH

MEMWATCH is an open source memory error detection tool. It works by defining MEMWATCH in gcc statement and by adding a header file to our code. Through this we can track memory leaks and memory corruptions. 这个工具十年没更新了！

### ftrace

ftrace is a good tracing framework for Linux kernel. ftrace traces internal operations of the kernel. This tool included in the Linux kernel in 2.6.27. With its various tracer plugins, ftrace can be targeted at different static tracepoints, such as scheduling events, interrupts, memory-mapped I/O, CPU power state transitions, and operations related to file systems and virtualization. Also, dynamic tracking of kernel function calls is available, optionally restrictable to a subset of functions by using globs, and with the possibility to generate call graphs and provide stack usage.

### ltrace

ltrace is a debugging utility in Linux, used to display the calls a **user space application makes to shared libraries**. This tool can be used to trace any dynamic library function call. It intercepts and records the dynamic library calls which are called by the executed process and the signals which are received by that process. It can also intercept and print the system calls executed by the program.

### perf

perf_events is an event-oriented observability tool, which can help you solve advanced performance and troubleshooting functions. Questions that can be answered include:

- Why is the kernel on-CPU so much? What code-paths?
- Which code-paths are causing CPU level 2 cache misses?
- Are the CPUs stalled on memory I/O?
- Which code-paths are allocating memory, and how much?
- What is triggering TCP retransmits?
- Is a certain kernel function being called, and how often?
- What reasons are threads leaving the CPU?

perf_events is part of the Linux kernel, under tools/perf. While it uses many Linux tracing features, some are not yet exposed via the perf command, and need to be used via the ftrace interface instead. My perf-tools collection (github) uses both perf_events and ftrace as needed.[来源](https://www.brendangregg.com/perf.html)

### KDB

KDB is the in-kernel debugger of the Linux kernel. KDB follows simplistic shell-style interface. We can use it to inspect memory, registers, process lists, dmesg, and even set breakpoints to stop in a certain location. Through KDB we can set breakpoints and execute some basic kernel run control (Although KDB is not source level debugger).

### KGDB

KGDB is intended to be used as a source level debugger for the Linux kernel. It is used along with gdb to debug a Linux kernel. Two machines are required for using kgdb. One of these machines is a development machine and the other is the target machine. The kernel to be debugged runs on the target machine. The expectation is that gdb can be used to "break in" to the kernel to inspect memory, variables and look through call stack information similar to the way an application developer would use gdb to debug an application. It is possible to place breakpoints in kernel code and perform some limited execution stepping. Several handy resources regarding KGDB:

## KDB vs KGDB

The kernel has two different debugger front ends (kdb and kgdb) which interface to the debug core. It is possible to use either of the debugger front ends and dynamically transition between them if you configure the kernel properly at compile and runtime.

Kdb is simplistic shell-style interface which you can use on a system console with a keyboard or serial console. You can use it to inspect memory, registers, process lists, dmesg, and even set breakpoints to stop in a certain location. Kdb is not a source level debugger, although you can set breakpoints and execute some basic kernel run control. Kdb is mainly aimed at doing some analysis to aid in development or diagnosing kernel problems. You can access some symbols by name in kernel built-ins or in kernel modules if the code was built with CONFIG_KALLSYMS.

Kgdb is intended to be used as a source level debugger for the Linux kernel. It is used along with gdb to debug a Linux kernel. The expectation is that gdb can be used to "break in" to the kernel to inspect memory, variables and look through call stack information similar to the way an application developer would use gdb to debug an application. It is possible to place breakpoints in kernel code and perform some limited execution stepping.

Two machines are required for using kgdb. One of these machines is a development machine and the other is the target machine. The kernel to be debugged runs on the target machine. The development machine runs an instance of gdb against the vmlinux file which contains the symbols (not boot image such as bzImage, zImage, uImage...). In gdb the developer specifies the connection parameters and connects to kgdb. The type of connection a developer makes with gdb depends on the availability of kgdb I/O modules compiled as built-ins or loadable kernel modules in the test machine's kernel.

[来源：网站](https://landley.net/kdocs/Documentation/DocBook/xhtml-nochunks/kgdb.html)


## Comparison

Pros and cons vs other methods:

advantage vs QEMU:

- you often don't have software emulation for your device as hardware vendors don't like to release accurate software models for their devices
- real hardware way faster than QEMU

advantage vs JTAG:

- no need for extra JTAG hardware, easier to setup

disadvantages vs QEMU and JTAG:

- less visibility and more intrusive. KGDB relies on the certain parts of the kernel working to be able to communicate with the host. So e.g. it breaks down in panic, you can't view the boot sequence.


[来源：Stack Overflow](https://stackoverflow.com/questions/4943857/how-is-linux-kernel-live-debugging-done-and-what-tools-are-used#:~:text=ltrace%20is%20a%20debugging%20utility%20in%20Linux%2C%20used%20to%20display%20the%20calls%20a%20user,used%20to)

## Linux的困境

想把Linux取消优化（即以`-O0`编译）是非常困难的，因为the kernel as a whole requires -O2 because the code itself is written with assumptions that certain functions will be optimized in a certain way. [来源：Stack Overflow](https://stackoverflow.com/questions/29151235/how-to-de-optimize-the-linux-kernel-to-and-compile-it-with-o0)

## 非源代码级操作系统调试工具

### ftrace

因此，需要重新编译内核，修改内核编译参数，因此仅限于Linux，本质上仍然相当于需要修改源代码。

With its various tracer plugins, ftrace can be targeted at different static tracepoints, such as scheduling events, interrupts, memory-mapped I/O, CPU power state transitions, and operations related to file systems and virtualization. Also, dynamic tracking of kernel function calls is available, optionally restrictable to a subset of functions by using globs, and with the possibility to generate call graphs and provide stack usage reports. At the same time, ftrace can be used to measure various latencies within the Linux kernel, such as for how long interrupts or preemption are disabled.[2][4][5]: 3–11, 14, 18 

An ftrace-enabled Linux kernel is built by enabling the CONFIG_FUNCTION_TRACER kernel configuration option. The entire runtime interaction with ftrace is performed through readable and writable virtual files contained in a specifically mounted debugfs file system; as a result, ftrace requires no specialized userspace utilities to operate.[2][3][6] However, there are additional userspace utilities that provide more advanced features for data recording, analysis and visualization; examples of such utilities are trace-cmd and KernelShark.[2][5]: 31–47 [7][8]

Internally, ftrace relies on the gcc's profiling mechanism to prepend machine instructions to the compiled versions of all source-level kernel functions, which redirect the execution of functions to the ftrace's trampolines and tracer plugins that perform the actual tracing. These "entry point" instructions created by gcc are altered by ftrace when the kernel is booted, and varied later at runtime by ftrace between NOPs and actual jumps to the tracing trampolines, depending on the tracing types and options configured at runtime.[9][10]

### KGDB

同样地，需要重新编译内核，打开CONFIG_KGDB. 仅限于Linux，本质上仍然相当于需要修改源代码。

Linus Trovalds 反对使用操作系统调试器，他认为不使用调试器反而能写出更好的代码：<https://lwn.net/2000/0914/a/lt-debugger.php3>

## 源代码级操作系统调试工具

### GDB

## 在线仿真器

在线仿真器（英语：In-Circuit Emulator，简称：ICE）是调试嵌入式系统软件的硬件设备。在线仿真器通过处理器的额外辅助功能，使系统在不失去其功能的情况下，提供调试功能。历史上，由于处理器能力有限，这通常意味着将其处理器临时更换成一个硬件仿真器。硬件仿真器是普通处理器的特制版本，内部设有多种额外的调试信号，以便提供处理器内部状态的信息。

而现今，在线仿真器也可以指在处理器上直接进行调试的硬件设备。由于JTAG等新技术的出现，人们可以直接在标准的量产型处理器上直接进行调试，而不需要特制的处理器，从而消除了开发环境与运行环境的区别，也促进了这项技术的低成本化与普及化。[来源：维基百科](https://en.wikipedia.org/wiki/In-circuit_emulation)

## 硬件

## blah
老的几个
https://getliner.com/share/09895f427gknhd
https://getliner.com/share/c8e0a4957gl02n

GDB-based ebpf-based(自检查)
关注方法而不是实践