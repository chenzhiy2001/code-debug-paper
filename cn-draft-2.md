# 支持Rust语言的源代码级操作系统调试工具

文章解决的核心问题：操作系统代码调试时，特权级切换导致符号表等调试信息丢失进而断点调试失败。（需要确认：内核架构是否有影响，比如宏内核、微内核等）
核心方法：
1、利用断点组缓存不同特权级的断点等调试信息
2、特权级切换检测，以及切换时的调试信息切换
实现部分：
基于vscode插件统一真实硬件和qemu模拟器的调试

## 摘要

## 1 Introduction 概述

操作系统开发者希望用 GDB 调试器或者它的继承调试环境来同时调试内核和用户态程序，而且断点是调试过程中一定会用到的功能。

然而，操作系统在特权级切换时会进行页表的切换，进而导致断点调试信息丢失，从而导致调试失败。

为了解决上述问题，我们利用断点组缓存不同特权级的断点等调试信息，同时通过边界断点进行特权级切换检测，从而能够在特权级切换时进行调试信息的切换，进而实现跨特权级，多进程的操作系统调试。

我们基于一个 VSCode 插件，在真实硬件和Qemu模拟器上实现了这种操作系统调试。

## 2 Motivation 动机

我们不妨假设一位开发者正在用 GDB 调试一个操作系统。该操作系统已经暂停在内核代码，且暂未运行过任何用户态进程。此时他想调试该操作系统将要进入到的第一个进程，即零号进程的代码。于是他加载了零号进程的符号表，并在 GDB 终端里输入了一行命令，请求设置一个位于零号进程的代码的断点。我们暂时称这个断点为 $ B_1 $。

GDB在执行这个命令时会依次做这几件事：

1. 从已经加载的符号表中推断出该断点的虚拟内存地址。我们暂时称这个这个内存地址为 $ A_1 $。
2. 将虚拟内存地址 $ A_1 $ 处的指令修改为一个特殊的中断指令（这个指令在 x86 处理器上是 `INT3`，在 riscv 处理器上是`ebreak`）。

然而，在执行步骤2时，会出现两种不寻常的情况：

1. 虚拟内存地址 $ A_1 $ 只被包含在零号进程的页表里，不被包括在内核的页表里。在这种情况下，在内核态下，虚拟内存地址 $ A_1 $ 是无法访问到的，因此GDB会认为这个断点目前无法设置，并将这个断点设置为 `PENDING` 状态，每一次被调试操作系统因单步或断点而停下来时，就重新尝试设置一次这个断点。

2. 虚拟内存地址 $ A_1 $ 不仅被包含在零号进程的页表里，也被包括在内核的页表里，但是在内核的页表里，虚拟地址 $ A_1 $ 并没有像零号进程的页表一样指向断点 $ B_1 $ 对应的二进制指令，而是指向其他无关内容。由于内核态下 $ A_1 $ 并不是断点 $ B_1 $ 对应的二进制指令的位置，GDB 会将一个无关指令（甚至可能是一些无关数据）修改为中断指令，在错误的物理地址处设置断点。

注：以上描述的是多页表的 rCore 的情况。单页表的 xv6 用户态进程已经加载/未加载的情况要再确认一下

总之，这两种不寻常的情况意味着，由于 GDB 不支持跨页表的断点设置，但是操作系统进行特权级切换后会切换页表，GDB 不能进行跨特权级的断点设置 [^1]。既然 GDB 只能设置当前页表的断点，我们很自然地想到，只要将所有的断点按照它们所属的页表进行分组，并且当每一次页表发生切换之后就设置当前页表的断点组，就可以规避上述问题，进而实现跨特权级的操作系统调试。

[^1]: 在一些特殊情况下，虚拟内存地址 $ A_1 $ 不仅被包含在零号进程的页表里，也被包括在内核的页表里，且在两个页表里，虚拟地址 $ A_1 $ 都指向断点 $ B_1 $ 对应的二进制指令。在这种情况下，断点 $ B_1 $ 可以成功地跨页表设置并触发。不过这种情况只会在断点 $ B_1 $ 设置在跳板页代码上时出现，不会在断点 $ B_1 $设置在用户态代码上时出现。）

## 3 Approach 方法

### A. 利用断点组缓存不同特权级的断点等调试信息

如上文所述，我们需要分组缓存不同页表下的断点。

接下来的内容：

- 断点组数据结构是什么样的
- 怎么判定一个断点属于哪个断点组：由于用户设置断点时，调试器能得到的信息只有断点所在文件名和行号，所以我们要求用户在配置文件中提供一个规则，设置文件名和断点组的映射关系。比如，所有在“内核”文件夹下的文件都属于叫做“内核”的断点组，所有“initproc”文件夹下的代码都属于“initproc”断点组。总不能真的去自动地找断点对应的页表吧
- 如果用户设置了一个断点，怎么进行处理
- 由于用户在大部分情况下设置的都是源代码断点，依赖于符号表，所以，由断点组名查找符号表文件的规则也需要用户在配置文件中提交。

### B. 特权级切换检测，以及切换时的调试信息切换

有了断点组之后，我们还需要一个在页表被切换后及时切换断点组的机制。由于 GDB 不能在被调试对象还在运行时设置断点，我们需要在每次页表被切换后停下来，接着设置断点组和符号表。一个很容易想到的办法是，在页表切换后的指令处设置断点（我们暂时称这个断点为 $ B_2 $ ），当 $ B_2 $ 被触发时就意味着页表已经发生了切换，在这个时机切换断点组即可。但是这个办法在逻辑上是不可行的，因为断点 $ B_2 $ 会遇到和断点 $ B_1 $ 同样的问题，无法被设置或触发。在页表切换指令或其之前的几个指令处设断点（我们暂时称这个断点为 $ B_3 $ ）同样是不可行的：虽然 $ B_3 $ 本身可以被正确触发，但是它被触发时尚未进行页表的切换，此时若切换到下一断点组，那么下一断点组的所有的断点都会遇到和断点 $ B_1 $ 同样的问题，无法被设置或触发。

由此可见，只是设置一个新的断点是不足以帮助完成断点组的切换的。但是，借助单步操作可以完成。

接下来的内容：

- 借助单步操作，怎么完成断点组的切换
- 当前断点组是什么，当前断点组是如何判定的

## 4 Implementation 实现

### A. 修改 Native Debug 插件

接下来的内容：

- 修改已有的用于调试用户态程序的 Native Debug VSCode 插件，为其增加Qemu支持。一键启动 Qemu + GDB。
- 修改调试器插件已有的断点设置和断点触发处理函数，接入断点组管理模块

### B. 状态机，多进程，硬件

接下来的内容：

- 多进程调试的流程是什么样的，调试器需要增加什么代码
- 由于添加多进程调试功能，代码维护起来比较繁琐，所以我们用一个状态机来整理代码，把以前的所有的跨特权级调试功能和多进程调试功能都囊括进去。这个状态机包括哪些 states, events, actions，分别起什么用途
- 在状态机之外，还有钩子断点，起什么作用

### C. 硬件调试

- 基本思路：用 OpenOCD 替换 Qemu 的 GDBStub
- RISC-V 的 stepie 的问题

## 5 Related Work 相关工作

## 6 Conclusion 结论
