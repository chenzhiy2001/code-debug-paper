# 支持Rust语言的源代码级操作系统调试工具

- 文章解决的核心问题：操作系统代码调试时，特权级切换导致符号表等调试信息丢失进而断点调试失败。（需要确认：内核架构是否有影响，比如宏内核、微内核等）

- 核心方法：
  1. 利用断点组缓存不同隔离环境的断点等调试信息
  2. 特权级切换检测，以及切换时的调试信息切换

- 实现部分：
  - 基于vscode插件统一真实硬件和qemu模拟器的调试

## 摘要

## 1 Introduction 概述

在远程调试（cross-debugging）操作系统时，现有的调试器只能单独调试操作系统内核或运行于该操作系统中的单个用户程序，无法同时调试内核和多个用户程序。具体来说（to be specifically），用户不能在被调试 OS 暂停在内核时设定某个用户程序的断点，也不可以在被调试 OS 暂停在一个用户程序时设置内核或者另一个用户程序的断点。

造成这种不便的原因是，操作系统为了防止用户程序对操作系统造成损害以及提高硬件资源的利用率，在内核和每个应用程序之间都做了隔离。隔离的措施主要有两个：1）内核代码和用户程序代码拥有不同的执行权限，换句话说，内核运行在内核特权级，用户程序运行在用户特权级；2）内核和每一个用户程序都拥有独立的上下文（context），特别是独立的地址空间。当互相隔离的内核/用户程序需要交互时，它们的执行流会通过系统调用和陷入返回（trap return）的方式切换到目标用户程序/内核。在这种隔离环境切换的过程中，除了处理器的特权级会切换到目标用户程序/内核的特权级以外，包括页表在内的上下文也会进行切换。

然而，这种页表的切换会导致以下问题：在大部分情况下，用户设置的是源代码断点。为了设置某个源代码断点，调试器需要在设置它之前加载该断点对应的源代码的**符号表**。符号表是程序源代码中的符号与程序的地址空间内虚拟地址的映射，然而上一段提到的第二个隔离措施（内核和每一个用户程序拥有独立的地址空间）意味着内核和每一个应用程序的符号表都是互相独立的，也就是说在设置断点的时刻，被调试操作系统所在的地址空间必须要和用户所设断点对应的符号表的地址空间一致才能正常运作。相反地，如果用户试图让调试器同时加载内核和多个用户程序的符号表并设置非当前隔离环境的断点，那么这些断点很有可能设置失败。我们将在第三章中详细说明这一点。

既然操作系统的隔离环境的切换导致符号表失效，进而无法设置跨隔离环境的断点，我们便想到将符号表根据它对应的隔离环境进行分组，并将断点根据它所依赖的符号表进行分组，分组后的断点称为**断点组**（breakpoint groups，复数）。符号表和每个符号表对应的断点组（breakpoint group，单数）都跟着隔离环境的切换而切换，从而使得调试器在被调试OS处于内核态时只加载内核断点和符号表，在被调试OS处于某个用户态程序时只加载该用户态程序的断点和符号表，因此得以避免前文所述的断点设置错误。

我们通过以下两个核心方法来实现这一思路。第一个核心方法是利用断点组缓存不同隔离环境的断点等调试信息。该方法依赖于两个用户提交的映射规则。第一个映射规则是从断点组名到符号表文件路径的映射规则。调试器在切换到某个断点组时会利用这个规则找到该断点组对应的符号表文件并进行符号表切换。第二个映射规则是源代码文件到断点组名的映射规则。用户在设置断点时，调试器会收到该断点的文件名和行号。调试器将该断点的文件名输入映射规则即可得知该断点属于的断点组，并将这个断点缓存于其中。如果该断点属于当前隔离环境，那么调试器除了将断点信息存储到断点组之外，还会将该断点立即设置下去。

第二个核心方法是通过有特殊功能的断点进行隔离环境切换检测，从而能够在隔离环境切换时进行调试信息的切换。如前文所述，调试器不能检测到隔离环境的切换，这导致被调试os的隔离环境切换时，调试器不能同步切换断点组，进而不能设置并触发多个隔离环境的断点。为了解决这个问题，我们设计并实现了两种特殊的断点。第一种特殊断点是**钩子断点**。钩子断点在被触发之后会执行用户自定义的命令，这些用户自定义的命令会读取并保存钩子断点被触发时被调试OS的上下文。第二种特殊断点是**出口断点**。出口断点的触发意味着隔离环境即将切换。例如，用户态程序的系统调用函数可以作为出口断点。在开始调试之前，用户需要人工（manually）分析操作系统的代码，在配置文件中提供钩子断点的文件名、行号、上下文收集和处理的流程，以及出口断点的文件名和行号。调试器启动之后，它会根据配置文件自动设置当前隔离环境下的断点组、钩子断点和出口断点。当钩子断点被触发后，调试器会收集上下文并判定出被调试os离开当前隔离环境后会切换到哪一个隔离环境，进而判定出哪一个断点组是下一个断点组。当出口断点被触发后，调试器会通过执行断点组切换的流程来切换到下一个断点组。

我们基于一个 VSCode 插件，在真实硬件和 Qemu 模拟器上实现了这种跨特权级，多进程的操作系统调试。

## 2 相关工作

### 2.1 调试器中的断点与单步

在调试器（如 GDB[参考文献]、LLDB[参考文献]、WinDBG 等）的实现中，“设置断点”通常通过指令替换（instruction replacement）来完成：调试器会将目标指令位置处的机器指令替换为一个特殊的中断指令（如 x86 架构中的 `INT3`、RISC-V 架构中的 `EBREAK`），一旦执行到该指令，处理器就会触发异常或陷入（trap），从而把控制权交还给调试器。这使得代码在该位置暂停，调试者可以检查寄存器、内存、堆栈等状态。但若断点所在位置无法被替换或读取（例如页表映射有差异），则会导致断点设置失败或无法触发的情况。

与断点机制不同，“单步执行”并不依赖于指令替换，而是通过处理器自身或调试器的单步模式来实现：在某些架构上，设置处理器的单步标志位或特权寄存器，即可在每条指令后自动触发异常，暂停执行；也可在软件层面通过反复设置短暂性的断点来模拟单步。这意味着某些断点“跳不过去”的指令（由于断点替换指令无效或地址不正确），调试器往往能通过单步方式一条一条地前进绕过，从而避免陷入断点设置失败的困境。

### 2.2 符号表

源代码级调试必须依赖调试信息文件（如 `ELF` 中的 DWARF 段[参考文献]），其中记录了符号表（symbol table）的信息。符号表把“源代码中的符号（函数名、变量名、行号等）”映射到“可执行程序（或库）在其地址空间内的虚拟地址”上。如果用户在某个源代码文件的某一行下断点，调试器会先通过符号表找到对应的虚拟地址，再将该地址替换为中断指令。

## 3 问题的展开描述

我们不妨假设一位开发者正在调试一个操作系统。该操作系统运行在真实硬件或 QEMU 虚拟机[参考文献]上，开发者通过 GDB 连接到目标环境的调试接口。在真实硬件上，这通常是基于 JTAG 协议[参考文献]的 OpenOCD 接口[参考文献]；而在 QEMU 中，则是其内置的 GDBStub 接口[参考文献]。该操作系统已经暂停在内核代码，且暂未运行过任何用户态进程。此时他想调试该操作系统将要进入到的第一个进程，即零号进程的代码。于是他加载了零号进程的符号表，并在 GDB 终端里输入了一行命令，请求设置一个位于零号进程的代码的断点。我们暂时称这个进程为 $ P_1 $，这个断点为 $ B_1 $ [^1]。

GDB在执行这个命令时会依次做这几件事：

1. 从已经加载的符号表中推断出该断点的虚拟内存地址。我们暂时称这个内存地址为 $ A_1 $。
2. 将虚拟内存地址 $ A_1 $ 处的指令修改为一个特殊的中断指令（这个指令在 x86 处理器上是 `INT3`，在 riscv 处理器上是`ebreak`）。

在执行步骤2时，如果内核和用户态程序共用一个页表，那么不论操作系统运行在内核还是该用户态程序，虚拟地址 $ A_1 $ 都指向断点 $ B_1 $ 对应的二进制指令，因此断点 $ B_1 $ 可以成功地设置并触发。但是，如果内核和用户态程序使用不同的页表，那么会出现两种不寻常的情况：

1. 虚拟内存地址 $ A_1 $ 只被包含在零号进程的页表里，不被包括在内核的页表里。在这种情况下，在内核态下，虚拟内存地址 $ A_1 $ 是无法访问到的，因此 GDB 会认为这个断点目前无法设置，并将这个断点设置为 `PENDING` 状态，每一次被调试操作系统因单步或断点而停下来时，就重新尝试设置一次这个断点。

2. 虚拟内存地址 $ A_1 $ 不仅被包含在零号进程的页表里，也被包括在内核的页表里，但是在内核的页表里，虚拟地址 $ A_1 $ 并没有像零号进程的页表一样指向断点 $ B_1 $ 对应的二进制指令，而是指向其他无关内容。由于内核态下 $ A_1 $ 并不是断点 $ B_1 $ 对应的二进制指令的位置，GDB 会将一个无关指令（甚至可能是一些无关数据）修改为中断指令，在错误的物理地址处设置断点。

这两种不寻常的情况意味着，由于 GDB 不支持跨页表的断点设置，但是操作系统进行特权级切换后会切换页表，GDB 不能进行跨特权级的断点设置。也就是说，如果内核和用户态程序使用不同的页表，那么 GDB 就不能同时设置内核和用户态程序的断点。

如果用户想利用断点同时调试被调试操作系统中的**多个**用户态进程，那么不论内核和用户态程序是否共用一个页表，GDB 都不能正确地同时设置不同用户态进程的断点。例如，假设用户在断点 $ B_1 $ 触发后命令 GDB 设置另一个进程 $ P_4 $ 的断点 $ B_4 $，GDB 会根据已有符号表解析出断点 $ B_4 $ 对应的内存地址 $ A_4 $ 并修改地址 $ A_4 $ 处的指令。然而，由于不同用户态程序的地址空间是重叠的（overlapping），在用户设置断点 $ B_4 $ 的这个时机，断点 $ B_4 $ 对应的地址 $ A_4 $ 指向的是当前运行的进程 $ P_1 $ 的某个指令，而非进程 $ P_4 $ 的指令。

综上所述，在调试操作系统时，由于 GDB 不能正确地设置非当前页表的断点，而操作系统却有频繁的页表切换，仅靠 GDB 本身进行操作系统的断点调试是不够的。在下一章中，我们将介绍我们设计的解决方案：利用一个外部模块进行断点分组、缓存和断点组切换，从而实现跨隔离环境的断点调试。

[^1]: 本文不讨论硬件断点（hardware breakpoint），只讨论软件断点（software breakpoint）的情况。

## 4 Design 设计

在上一章中，我们详细地分析了跨隔离环境的断点调试中遇到的问题。为了解决这些问题，我们设计了一个称为**断点组管理模块**的外部模块。该模块介于用户界面和 GDB 调试器之间，可以拦截用户的断点设置请求，并且将这些断点按照它们所属的页表进行分组保存，并且保证 GDB 只设置当前页表下的那一组断点（我们称这一组断点为当前断点组）。非当前页表的断点均缓存在断点组管理模块中，不为 GDB 所知。

我们先证明这种断点缓存策略的正确性（即不会出现应当被触发的断点没被触发，或者断点被错误地触发的情况），再介绍断点组管理模块的断点缓存策略、下一断点组的获取策略和断点组切换的流程。

### 正确性

不失一般性地，我们接着以第三章所述场景为例。如果用户设置断点 $ B_4 $ 的命令在 GDB 执行它之前经过断点组管理模块的过滤，那么该模块就会检测到断点 $ B_4 $ 不属于当前运行的进程 $ P_1 $ 的页表，进而不将设置断点 $ B_4 $ 的命令传递给 GDB，而是将它缓存到进程 $ P_4 $ 的页表对应的断点组中。等到断点组管理模块检测到 OS 已经切换到进程 $ P_4 $ ，断点组管理模块会命令 GDB 删掉旧的断点组的断点，并设置进程 $ P_4 $ 对应的断点组的断点，而这个断点组中就包含了断点 $ B_4 $。

既然断点 $ B_4 $ 属于进程 $ P_4 $，那么断点 $ B_4 $ 只有可能在 OS 运行进程 $ P_4 $ 时被触发，所以在 OS 切换到进程 $ P_4 $ 之后立即设置包含断点 $ B_4 $ 的断点组，且在 OS 因为系统调用或进程结束而离开进程 $ P_4 $ 之后令 GDB 把包含断点 $ B_4 $ 的断点组的断点删掉，使这些断点组恢复到缓存状态（即断点组管理模块中有这些断点组的内容，但是 GDB 中没有设置这些断点组里的断点），可以保证断点 $ B_4 $ 正确地被设置和完全地被触发。

### 将断点缓存到断点组

如前文所述，断点组管理模块可以拦截用户设置断点的命令。因此，只要断点组管理模块能够从用户的断点设置请求中判断该断点属于哪个断点组，且如果该断点属于当前断点组，将该断点立即令 GDB 设置，那么断点组管理模块就能实现我们想要的断点缓存功能。

考虑到用户设置断点的命令中，通常包含了断点的源代码文件名和行号（在此处我们暂不讨论直接设置内存地址断点的情况），因此我们要求用户在配置文件中提交一个规则，这个规则指定了断点的源代码文件名到断点组名的映射。例如，如果所有在“initproc”文件夹下的代码文件都属于initproc进程的页表，那么用户可以在配置文件中将“initproc”文件夹下的代码文件都映射到一个叫做“initproc_breakpoints”的断点组。有了这样的映射之后，每一个断点都可以被归类到对应的断点组里。

由于本模块的核心功能是保证只设置当前页表下的断点，而我们已经有了一个将断点设置命令归类到不同页表的机制，那下一步要做的是确定哪一个断点组是 OS 当前的断点组。

由于在一些处理器，比如risc-v中，并没有一个寄存器可以直接指定当前特权级[参考文献]，所以在一些情况下，我们无法直接判断出当前所在的特权级及页表信息。我们采取的办法是，在每一个断点组中添加一个我们称为**出口断点**的断点。这个断点的作用是，一旦这个断点触发了，就表示操作系统即将离开当前的断点组。例如，内核断点组的出口断点设置在内核的上下文切换代码，用户态程序所属的断点组的出口断点设置在syscall指令处。在操作系统调试开始时，断点组管理模块的当前断点组默认为内核断点组。一旦边界断点触发，断点组管理模块就会将当前断点组切换到下一个断点组。由于操作系统内往往同时运行内核和多个用户程序，断点组管理模块内通常有多于 2 个的断点组。我们将在下一小节介绍如何判断其中哪一个断点组是断点组管理模块将要切换到的下一个断点组。

### 获取下一个断点组名的方法

获知哪个断点组是下一个断点组的方式是，在断点组管理模块内部保存有两个属性，第一个为“下一个断点组”，第二个为“下下一个断点组”。这两个属性的初始值是由用户在配置文件中指定的。一般情况下，用户应当配置“下一个断点组”为零号进程所属的断点组，“下下一个断点组”为内核断点组（因为操作系统进入零号进程后会返回内核）。例如，操作系统运行在内核时，“下一个断点组”是零号进程断点组，当操作系统从内核切换到零号进程后，断点组调试模块会将“下一个断点组”和“下下一个断点组”的值互换，使得当操作系统从零号进程返回到内核前，“下一个断点组”为内核断点组。当操作系统从零号进程返回内核后，“下一个断点组”和“下下一个断点组”再次进行对调，使得“下一个断点组”变为零号进程断点组，“下下一个断点组“变成内核断点组。此时“下一个断点组”的值是错误的。我们利用我们称之为**钩子断点**的特殊断点在内核代码执行期间获取到正确的下一个断点组名并赋值给“下一个断点组”变量。“钩子断点”被触发时，GDB 调试器会自动执行一些用户自定义的行为。这些用户自定义的行为会捕捉到下一个断点组的正确的值。例如，用户可以把钩子断点设置在内核的调度代码，并在钩子断点的行为函数中，将该断点触发后的行为设置为捕获某个变量代表的字符串，并将该字符串用用户设定的规则进行拼接，进而得到正确的“下一个断点组”变量的值。因此，操作系统在从零号进程返回内核之后会触发钩子断点，钩子断点捕获到下一进程名后，断点组管理模块中的“下一个断点组”变量会从“零号进程断点组”切换为下一个要运行的进程的断点组名。

### 断点组切换流程

当出口断点被触发后，我们除了要将“当前断点组”变量更新，还需要将断点组本身进行切换。由于 GDB 不能在被调试对象还在运行时设置断点，我们需要在每次页表被切换后停下来，接着切换断点组和符号表。一个很容易想到的办法是，在页表切换后的指令处设置断点（我们暂时称这个断点为 $ B_2 $ ），当 $ B_2 $ 被触发时就意味着页表已经发生了切换，在这个时机切换断点组即可。但是这个办法在逻辑上是不可行的，因为断点 $ B_2 $ 会遇到和断点 $ B_1 $ 同样的问题，无法被设置或触发。在页表切换指令或其之前的几个指令处设断点（我们暂时称这个断点为 $ B_3 $ ）同样是不可行的：虽然由于断点 $ B_3 $ 本身和设置它时操作系统所在的页表是一致的，因此可以被正确地设置和触发，但是它被触发时尚未进行页表的切换，此时若切换到下一断点组，那么下一断点组的所有的断点都会遇到和断点 $ B_1 $ 同样的问题，无法被设置或触发。

由此可见，只是设置一个新的断点是不足以帮助完成断点组的切换的。但是我们注意到，断点 $ B_3 $ 和断点 $ B_2 $ 分别可以完成切换断点组的一半工作：

1. 如果操作系统暂停在断点 $ B_3 $ 所在的指令处（如前文所述，断点 $ B_3 $ 本身和设置它时操作系统所在的页表是一致的，所以让 GDB 设置断点 $ B_3 $ 就可以促成这个情况的发生），那么 GDB 可以成功地卸载旧断点组的断点，因为此时旧断点组的断点所属的页表和卸载旧断点组的断点时操作系统所在的页表是一致的；

2. 如果操作系统能够暂停在断点 $ B_2 $ 所在的指令处（尽管我们无法通过提前设置断点 $ B_2 $ 来促成这个情况的发生，但是可以在断点 $ B_3 $ 触发后进行数次单步来促成这个情况的发生），那么 GDB 可以成功地设置新断点组的断点，因为此时新断点组的断点所属的页表和加载新断点组的断点时操作系统所在的页表是一致的；

因此，GDB 只需要设置断点 $ B_3 $，断点 $ B_3 $ 被触发后再利用**反复的自动单步操作**到达断点 $ B_2 $ 所在的指令处，就可以利用这两次被调试操作系统的暂停共同完成断点组的切换，避开了无法提前设置断点 $ B_2 $ 的问题。当操作系统运行在某一页表下时，先设置这个页表下的断点 $ B_3 $（我们称这个断点为“出口断点”，因为它的触发意味着操作系统即将离开当前的页表，因此需要进行一部分断点组切换的工作）。在断点 $ B_3 $ 被触发后，GDB 卸载旧断点组的断点，然后让 GDB 不断地进行单步操作，直到它暂停在断点 $ B_2 $ 所在的指令处。接着，GDB 再设置新断点组的断点。

需要注意的是，由于断点组管理模块中保存的断点都是源代码断点，而设置一个源代码断点之前，它对应的符号表必须已经加载，因此，在设置新断点组的断点之前，断点组管理模块需要查找到新断点组依赖的符号表，并且让 GDB 加载这些符号表。类似地，在卸载完旧断点组的断点之后，旧断点组的符号表需要卸载掉，以免和新断点组的符号表产生冲突。断点组和它对应的符号表文件的映射关系也需要用户在配置文件中提交。

## 5 Implementation 实现

本章节将介绍我们如何修改已有的用于调试用户态程序的 Native Debug VSCode 插件[参考文献]实现跨特权级、多进程的操作系统断点调试。

### 5.1 实现总体框架

Native Debug 插件[参考文献] 是一个用于调试用户态程序的 VSCode 插件。该插件基于 Debug Adapter 协议[参考文献]，bridge了 VSCode 编辑器的调试界面和 GDB 调试器的调试命令。我们的整体思路是在该插件中

调试器与被调试目标之间加入一个**断点组管理模块**，配合自定义的“出口断点”与“钩子断点”机制，实现针对不同隔离环境（或不同进程）断点的自动切换与正确触发。

在开始实现前，我们需要解决两个关键问题：  
1. **如何拦截并管理**用户在 VSCode 或 GDB 前端输入的“设置断点、删除断点”等调试命令。  
2. **如何检测并切换**操作系统当前所处的特权级或页表环境，从而动态地加载或卸载对应的断点和符号表。

为此，我们在现有的 VSCode 调试插件（基于 [Native Debug](https://marketplace.visualstudio.com/items?itemName=webfreak.debug)）中进行了如下改造：

1. **添加对 QEMU 启动与 GDBStub 连接的支持**  
   - 在 VSCode 中新增启动命令，一键同时启动 QEMU（或真实硬件上的 OpenOCD）和 GDB 调试器。  
   - 插件会自动使用 `target remote :1234`（或 JTAG/OpenOCD 的端口）进行远程连接。

2. **插入断点组管理模块**  
   - 对 VSCode 插件原有的“设置断点”请求进行二次封装：先由断点组管理模块根据源文件路径或用户配置，判定该断点属于哪个断点组，再决定是否真正将“set breakpoint”命令透传给 GDB。  
   - 在触发断点事件或暂停事件时，VSCode 插件调用断点组管理模块进行判定，确定是否需要做“断点切换”“符号表切换”或“单步移动到下一断点”等操作。

3. **与 GDB 同步更新状态机**  
   - 当 GDB 停下来（例如断点或单步触发），插件会检查当前的寄存器状态（PC 值、特权级等）或通过“钩子断点”捕获到的上下文，更新内部的**上下文状态机**（用于多进程或多特权级的识别），从而决定是否需要执行后续的断点组切换流程。

借助上述结构，我们实现了一个可在 VSCode 中自动化、多进程、多特权级调试的整体框架，如图所示（示意）：

```
┌─────────────────────┐
│       VSCode        │  
│     (UI + 插件)      │
└─────────┬───────────┘
          │  调试命令  
          ▼
┌─────────────────────┐
│  断点组管理模块 (本) │  
│ - 断点组缓存/切换   │
│ - 符号表切换        │
│ - 出口/钩子断点管理 │
└─────────┬───────────┘
          │  GDB命令
          ▼
┌─────────────────────┐
│         GDB          │
└─────────┬───────────┘
          │  RSP(远程调试协议)
          ▼
┌─────────────────────┐
│  QEMU / OpenOCD /   │
│  真实硬件调试接口    │
└─────────────────────┘
```

### 5.2 核心功能模块

基于上述总体框架，我们将实现重点放在“断点组管理模块”与“上下文状态机”这两大核心模块上，并结合“出口断点”和“钩子断点”来完成动态切换。

#### 5.2.1 断点组管理模块

**（1）数据结构设计**  
我们在插件内部维护一个名为 `BreakpointGroups` 的词典（HashMap / Dictionary），其键为“断点组名”，值为一个断点信息列表。示例结构如下：

```plaintext
BreakpointGroups = {
  "kernel_bp_group": [
    { file: "src/kernel/trap.c", line: 120, ... },
    { file: "src/kernel/sched.c", line: 85,  ... },
    ...
  ],
  "initproc_bp_group": [
    { file: "user/initproc.c", line: 30,  ... },
    ...
  ],
  ...
}
```

- **断点组名**：用户在配置文件中定义，如 `kernel_bp_group`、`initproc_bp_group` 等。  
- **断点信息**：包含源文件、行号、是否为出口断点/钩子断点等扩展字段。  

**（2）断点映射规则**  
当用户在 VSCode 中设置断点时，调试请求会先传给断点组管理模块。模块会根据配置文件中给出的“源代码路径 → 断点组名”的规则，将该断点归类到特定组。例如：  
- `if "user/initproc.c" in filePath => groupName = "initproc_bp_group"`  
- `if "kernel/" in filePath => groupName = "kernel_bp_group"`  

**（3）断点组的加载与卸载**  
- **加载**：只有“当前断点组”才会被实际下发到 GDB。  
- **卸载**：当检测到操作系统即将退出某个断点组（通过出口断点或单步逻辑识别），则将原先加载到 GDB 的断点一并删除。  
- **缓存**：其余断点组一直保存在 `BreakpointGroups` 词典中，不会被真正加载到 GDB。

**（4）符号表切换**  
由于断点多基于“源代码级”方式设置，GDB 在加载断点前须先加载符号表。因此，每个断点组都在配置文件中绑定了对应的“符号表路径”。在切换断点组时，断点组管理模块会：  
1. 卸载上一个断点组对应的符号表。  
2. 向 GDB 发送加载新的符号表命令 (`symbol-file XXX`)。  
3. 根据新断点组的断点信息，再一并下发 `break` 命令。

#### 5.2.2 上下文状态机

针对多进程或多特权级切换，代码逻辑若仅靠分散的 if-else 判断易失去可维护性。为此，我们将“内核态/用户态、多进程调度”等逻辑抽象为一个简单的**有限状态机（FSM）**。示例如下：

- **States**：  
  - `Kernel_State`  
  - `UserProc_State(pid=0)`  
  - `UserProc_State(pid=1)`  
  - …  
- **Events**：  
  - 出口断点触发（意味着即将离开当前页表）  
  - 钩子断点触发（捕获下一进程 ID 或上下文信息）  
  - 单步到新的 PC 范围（意味着页表已经切换完毕）  
- **Actions**：  
  - 调用 `unloadBreakpointGroup(oldGroup)`  
  - 调用 `loadBreakpointGroup(newGroup)`  
  - 动态更新“下一个断点组”变量  

通过该状态机，我们可以在调试器每次停下时，根据“当前状态 + 触发事件”来决定下一步执行哪些操作。这样既能处理多进程场景（例如从进程 0 切换到进程 4），也能处理跨特权级场景（例如从内核态切换到某个用户态进程）。

---

### 5.3 调试环境概览与示例

在给出具体的跨特权级、多进程调试流程示例之前，我们先简要说明本调试工具所支持的环境，以及若要适配新的操作系统、CPU 架构时需要做哪些工作。随后，我们将以一个典型调试流程的示例来呈现该工具如何在 VSCode 中帮助开发者调试内核与用户态代码。

---

#### 5.3.1 调试环境与适配说明

本工具基于 GDB 远程调试协议，理论上可以支持大多数具有 GDBStub 或 OpenOCD 接口的硬件/模拟器平台。为了方便读者理解和后续改造，我们在下表中汇总了目前已测试验证的操作系统、CPU 架构与编程语言，并给出了若要移植到其他环境时需关注的要点。

| 类别         | 已验证示例                                                      | 适配要点                                                     |
| :----------- | :-------------------------------------------------------------- | :----------------------------------------------------------- |
| **操作系统** | **rCore-Tutorial** (Rust 实现的教学 OS)<br/>**xv6** (MIT 教学 OS)<br/>**Starry** (一款用于教学和竞赛的微内核 OS) | 不同 OS 的页表切换、进程调度位置、特权级入口（如 `syscall`、`trap` 等）需预先人工分析，并在配置文件中指定“出口断点”或“钩子断点”。若需支持更多内核（如 Linux），则需编写更完善的断点配置规则。 |
| **CPU 架构** | **RISC-V** (QEMU 模拟与部分真实硬件)<br/>（可扩展）x86、ARM     | 若移植到 x86/ARM，需要在“单步执行”“断点指令替换”等方面做相应修改；多数情况下只需调整汇编指令（如 `EBREAK`→`INT3`）。 |
| **编程语言** | **Rust**（已验证 rCore、Starry 等）<br/>**C**（已在 xv6 测试）  | 编程语言只要能生成可供 GDB 识别的符号表（如 ELF+DWARF），原则上都可支持。本工具对 C++ 亦无硬性限制，但尚未做大规模测试。 |

> 表 5-2 本工具已验证的环境与适配要点  

在使用上述 OS 或 CPU 环境时，本工具已能完成基本的跨特权级和多进程调试需求，如在教学 OS 上调试内核调度与用户态应用、或在 OS 竞赛中快速定位进程异常等。若需要针对更复杂的生产操作系统或嵌入式平台进行适配，最主要的工作在于配置“**出口断点**”与“**钩子断点**”，即找到合适的内核/用户切换位置和调度相关函数，并在配置文件中加以标注。

> **提示**：图 5-2 示意了本工具在 VSCode 内核态/用户态联合调试时的典型界面，包括“多断点组切换列表”、“实时查看进程 PID”以及“自动加载符号表”等功能模块。

<div align="center">
  <i>（此处插入说明调试器功能的示意图，如 VSCode 界面截图或流程图，示例占位）</i>
</div>

#### 5.3.2 示例：跨特权级、多进程的调试过程

下面举一个简化示例，说明在 VSCode 中如何使用本工具进行跨特权级和多进程的联合调试。假设我们以 RISC-V + QEMU 模拟环境、配合 rCore 教学 OS 进行测试，rCore 内核会在某个时刻创建用户进程并进行进程调度。

1. **用户启动 VSCode 调试**  
   - 用户在 `launch.json` 中配置了 QEMU + GDB + 断点组管理模块的启动脚本，一键启动后，QEMU 挂起在内核起始位置等待调试。  
   - 同时加载“kernel_bp_group”的符号表。

2. **加载配置文件**  
   - 断点组管理模块读取名为 `breakpoints_config.json` 的配置文件，其中包含：  
     - “源代码路径”到“断点组名”的映射；  
     - 每个断点组对应的“符号表路径”；  
     - 出口断点、钩子断点的源文件及行号。  

3. **内核态初始断点组加载**  
   - 模块将 `kernel_bp_group` 中的断点实际下发到 GDB。  
   - 假设其中包含某个“出口断点”，位于 `kernel/trap.c:120`，用于捕捉内核即将切换到用户进程的时机。

4. **出口断点触发**  
   - 当系统执行到 `trap.c:120` 时，GDB 抛出暂停事件。断点组管理模块检测到“出口断点”被触发，说明内核即将切换到用户态。  
   - 模块先卸载 `kernel_bp_group` 的断点；然后执行“单步”操作若干次，直到模块识别出“页表已切换至 0 号进程”或“钩子断点捕获到 pid=0”之类的标志。

5. **自动切换到 0 号进程断点组**  
   - 当模块确认已经到达 `UserProc_State(pid=0)`，它会根据配置文件加载 `initproc_bp_group` 对应的符号表，并设置断点。  
   - 若该进程也有一个“出口断点”（比如在 `ecall` 指令处），下次触发时再进行类似逻辑的切换。

6. **钩子断点捕获下一个调度进程**  
   - 若内核再次调度新进程（比如 `pid=4`），则在回到内核态时触发“钩子断点”，获取调度器中的全局变量 `next_pid` 值为 4。模块更新“下一个断点组”为 `userproc4_bp_group`，并在后续的“出口断点 + 单步操作”后，自动切换到进程 4 的断点组。

7. **多进程轮转调试**  
   - 通过不断重复“出口断点 → 单步 → 加载新断点组”的模式，开发者即可在 VSCode 中跨进程、跨特权级灵活设置断点并单步调试，不必手动来回加载/卸载符号表。

在该示例中，利用“断点组管理”与“自动单步检测”机制，大大简化了**同时调试内核态与用户态**的流程，尤其在多进程 OS（如 xv6、rCore）或者教学/竞赛环境中成效显著。调试者只需专注于业务逻辑，不再为频繁切换内核/用户态断点而手忙脚乱。

### 5.4 小结

本章介绍了我们针对跨特权级与多进程操作系统调试所做的具体实现，包括在 VSCode + GDB 框架下增设**断点组管理模块**、利用**上下文状态机**统一管理不同进程或不同隔离环境的断点切换，并通过“出口断点 + 钩子断点 + 自动单步”的方式完成页表切换节点的捕捉和符号表的切换。  
在下一章的实验部分，我们将展示如何在真实硬件与 QEMU 环境中对一款支持 Rust 语言的操作系统进行多进程联合调试，并评估该方法在使用便利性和调试准确性上的表现。

## 6 Conclusion 结论

## 7 ref 参考文献

自己的论文

gdb, openocd, debug adapter, native debug, ebpf, xv6, starry, rCore-tutorial, qemu, gdbstub, riscv

[Ros09] Steven ROSTEDT. « Debugging the kernel using Ftrace ». http://lwn.net/
Articles/365835/, December 2009.

[6]. Free Software Foundation, Inc. “Debugging with gdb: the GNU Source-Level Debugger”, 
The Tenth Edition 
(https://software.intel.com/sites/default/files/article/365160/gdb.pdf) 

[Com10] DWARF Debugging Information Format Committee. DWARF
Debugging Information Format version 4. Tech. rep. June 2010.

[Rat] Dominic Rath. Open On-Chip Debugger. url: https://openocd.
org/. (accessed: 28.08.2021).

[Teaa] Rust Team. Debugging support in the Rust compiler. url: https:
//rustc-dev-guide.rust-lang.org/debugging-support-in-
rustc.html. (accessed: 18.08.2021).

[Teab] The LLVM Team. Source Level Debugging with LLVM. url: https:
/ / llvm . org / docs / SourceLevelDebugging . html. (accessed:
28.09.2021).

[3] Högl H, Rath D. Open on-chip debugger–openocd–[J]. Fakultat fur Informatik, Tech. Rep, 2006.