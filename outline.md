# 支持eBPF的操作系统源代码级操作系统调试工具
## 摘要
方便的源代码级调试工具，对监测程序运行状态和调试程序十分重要，尤其是复杂的内核代码。现有Rust操作系统开发领域缺少一款源代码级调试工具，导致相关实验环境搭建成本高，上手难度大，不利于Rust操作系统内核学习与开发工作。针对上述需求，本工作构建一款支持Rust操作系统内核开发的源代码级调试工具，该工具具备如下特征（1）基于QEMU和GDB，支持跨内核态和用户态的源代码跟踪调试；（2）基于eBPF，支持开发板上跨内核态和用户态的性能分析检测；（3）基于VScode构建了远程开发环境，支持断点调试与性能检测的功能结合。


## 概述（Introduction）

### 1.1 研究背景和意义
内核代码的调试难度大通常是阻碍开发人员进行操作系统功能开发的重要因素。由于操作系统内核代码复杂，静态分析、动态分析都具有相当的难度，包括特权级切换，进程调度，页表管理等。已有的集成开发环境通常面向应用程序的开发，对操作系统代码特别是新兴的Rust操作系统代码开发调试暂未提供良好的支持。如何提供方便、高效且可跨特权级跟踪的操作系统调试工具是待解决的关键问题。为了解决该问题，本工作将GDB与eBPF结合，通过远程访问的形式，提供方便的Qemu与实际硬件环境的Rust操作系统的开发与调试。实现用户态、内核态代码的静态断点调试与动态跟踪调试结合，提供了基于VSCode插件的用户交互界面。

我们主要解决以下三个关键问题：

(1) 支持基于GDB的内核态，用户态代码联合断点调试；

(2) 基于eBPF的内核态，用户态代码的动态跟踪调试；

(3) 远程开发环境下的用户界面（集成开发环境）支持与qemu，实际硬件（部分完成）的支持。

在我们前年发表的这篇论文[1]中，本工作已经实现（1）中部分功能，即内核态与0号用户进程的联合断点调试，在今年的工作中，我们在上述基础上进一步实现了内核态与不同用户进程的联合断点调试，并完善了特权级切换功能，具体请见第xxx节内容。除此之外，（2）中的技术问题已基本实现，具体请见第xxx节内容，而（3）中关于实际硬件的支持由于时间关系只做了部分的尝试，目前只能完整支持基于Qemu的开发环境，具体请见第xxx节内容。此外，本工作基于已实现的调试器完成了一个HTTP网页应用的调试，并成功定位到一个疑难问题，具体请见第xxx节内容。

### 1.2 工作内容概要

我们的工作主要解决了 Rust 操作系统的跨特权级调试跟踪，和静态动态调试相结合的问题。在解决这些问题的过程中，我们主要实现了以下几个技术：

1.  “断点组切换” 机制。在前年的论文[1]上，我们实现了“断点组机制“的一个演示性的版本，当时它仅有一个简单的框架，还不具备实用性。在去年工作的基础上，我们结构化代码，修补了大量漏洞，增添部分实用功能，构建了全新的”断点组切换“用户界面，还整理了一份详细，实用的用户文档（已经有多位同学和老师根据文档配置好了调试器），将所有硬编码的代码都替换为可配置的参数，还在 rCore-Tutorial-v3 之外，支持了一个新的OS（清华大学的ArceOS[2]），从而使得GDB可以方便、稳定地同时跟踪内核态和用户态代码；
2. 在常用教学操作系统 rCore-Tutorial-v3 中支持 eBPF 技术，移植 kprobe 模块和 eBPF 虚拟机模块，基于另一个 OS 的紧耦合的 uprobe 代码编写了一个模块化的 uprobes 模块并移植到 rCore-Tutorial-v3 上，从而内核和应用程序代码都可以用 eBPF 技术进行动态调试；

3. 将 eBPF 技术和 GDB 调试相结合，使得用户可以同时使用两种技术跟踪调试同一个OS。我们利用 GDB 的 Python 脚本功能，扩展原有的 GDB/RSP 协议，让一个GDB同时连接、控制两个 GDBServer（Qemu 提供的 GDBStub 和我们编写的基于 eBPF 技术的 eBPF Daemon），从而使得对两个调试技术的控制统一于一处；

4. 提供完整的图形化界面和自动化功能，使得用户在调试的过程中不需要输入任何终端命令。

## 系统调用跟踪
### 利用GDB进行syscall跟踪的传统方法
### 利用VSCode进行自动化的系统调用跟踪
#### VSCode提供的自动化API
#### 特权级切换时自动进行单步
#### 断点组切换
### 展望 - 怎么通过软硬件结合的方法跟踪异常
这个事情是朱毅在泉城的时候跟我说的。他意思是说
## eBPF增强跟踪能力
### 什么是eBPF（eBPF不影响OS的运行状态）用eBPF的好处（更加灵活，缓解编译器调试信息不全带来的种种困扰。GDB就像x光，eBPF就像肠镜）
### 我们用eBPF进行调试的思路（插桩-运行eBPF收集信息-利用串口输出信息）
### 以rCore-Tutorial-v3为例，怎么实现这种跟踪能力
#### 给rCore-Tutorial-v3添加eBPF
##### 模块化了别人的库
##### OS本身的修改
#### 传输调试信息
##### 怎么添加串口输入输出的功能
##### GDB怎么同时把两种调试信息处理清楚
## 一个实际的debug例子，用文本的GDB很难弄清楚，但是用调试器就能快速搞定的
## 致谢
## 引用
[1] 前年发的那篇小论文
[2] ArceOS的链接