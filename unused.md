# 没有使用的文段

## chp2

## chp3

实现断点组管理模块需要四个部分：
问题

获取到当前所在的页表，

GDB 仅管理当前断点组下的断点，其它的断点缓存在 GDB 上层的模块里。

这个模块保存了所有断点的信息，而且以断点所属的页表进行分组。它当它检测到页表切换时，是 GDB 上层的工具，将会控制 GDB 进行 只设置当前。GDB 本身只知道当前这个断点组下的断点。

断点断点组方法是什么样的，能缓存不同特全集的断点，特权级切换的时候的问题，断点组加进去之后会有什么问题/后果，方法做了什么东西123，怎么检测符号表特全集切换，有什么难点

用户态程序的边界这个断点的调试刚开始时默认当前断点组为内核


由于该模块不断地令 GDB 添加和删除断点，

由于该模块的一个关键功能是拦截用户设置断点的命令，且用户在断点设置命令中通常通过指定文件名和行号（而不是直接指定内存地址）来设置断点，断点组管理模块中的每个断点都是从断点设置命令的“文件名”和“行号”两个属性组成。考虑到

考虑迟到

这种机制是同步的，所以异步的异常无法跟踪

由于该模块的核心功能是以组为单位切换断点，我们将同一组断点

我们使用一个词典。将断点的数据放在一个列表（array）中，

断点组管理模块

起名规则由用户提供，一般而言是 

内存地址空间的代号，元素的值是这个代号对应的断点组，即这个内存地 址空间里的所有断点。

存命令更加直接

### 由一个外部模块（我们称之为断点组管理模块）保存所有的断点信息 - 怎么拦截

- 断点组数据结构是什么样的

如上文所述，我们需要分组缓存不同页表下的断点，且在每一个时刻都只有当前页表下的那一组断点被设置。但是，GDB 本身并没有这种分组缓存、设置的功能。为了实现这种功能，我们设计了一个处于 GDB 上层的模块，我们称之为断点组管理模块。这个模块能够拦截用户设置断点的命令，并将这些设置断点的命令按照命令中所请求设置的断点所属的页表进行分组保存。同时，这个模块具有检测当前所在页表的功能。利用这个功能，断点组管理模块只将与当前所在页表兼容的那一组断点（我们称之为当前断点组）通知给 GDB 进行设置。真正被设置的只有当前断点组，如果用户在调试过程中动态增加或删减了某个断点，不仅断点组中的 这样，GDB 在任一时刻都只设置、管理当前页表下的断点，其他的断点都没有被 GDB 设置，而是以断点设置命令的形式被分组缓存在断点组管理模块里，从而避免了第二章所述的跨页表设置断点带来的冲突。

将这些用户想要设置的断点的文件名和行号（因为是源代码断点）保存在该模块自己的数据结构中，并且只设置当前的断点组。用户的断点信息都，并对用户设置的断点进行分组、缓存，而 GDB 只知道当前的断点组。

### 该模块会将所有的断点按照它们所属的页表进行分组 - 怎么分组

断点映射到断点组,断点组映射到符号表

### 并且保证 GDB 只设置当前页表下的那一组断点 - 怎么检测当前页表，怎么检测到页表要切换（怎么利用边界断点找到断点组切换的时机），怎么切换断点组

- 当前断点组是什么，当前断点组是如何判定的

实现这个断点组管理模块的的难点有两个。第一个是如何判定断点所属的页表。考虑到用户设置断点时，用户提供的信息只有断点的文件名和行号，且用户自己一般都会知道某个源代码文件会运行在哪个页表下（比如，所有在“initproc”文件夹下的代码文件都属于initproc进程的页表），所以我们要求用户在配置文件中提供一个规则，设置文件名和文件名中代码所在的页表的映射关系。比如用户可以在配置文件中将“initproc”文件夹下的代码文件都映射到一个叫做“initproc_breakpoints”的断点组。

断点组管理模块用一个词典保存所有的断点组。词典的键是
断点组管理模块用一个词典缓存了用户要求设置的(包括内核态和用户态)所有断点。词典 中某个元素的键是内存地址空间的代号，元素的值是这个代号对应的断点组，即这个内存地 址空间里的所有断点。当任何一个断点被触发时，Debug Adapter 都会检测当前触发的这个 断点属于哪个断点组。包含了最新触发断点的断点组称为当前断点组(Current Breakpoint Group)。

第二个难点是 当前所在页表 出口断点

- 用户在大部分情况下设置的都是源代码断点，而设置一个源代码断点之前，它对应的符号表必须事先加载。但是，我们不可以在调试刚开始时就把内核和所有用户进程的符号表都加载到 GDB 里，因为这些符号表，特别是不同的用户态程序的符号表，经常是冲突的。所以，不同的符号表需要分别和它们所对应的断点组一起动态加载和卸载。断点组和它对应的符号表文件的映射关系也需要用户在配置文件中提交。

### 非当前页表的断点均缓存在断点组管理模块中，不为 GDB 所知。 - 怎么同步

- 如果用户设置了一个断点，怎么进行处理

在调试流程刚开始时，当用户设置

下一个用户态进程的问题


## others

调试是操作系统开发的重要组成部分。调试操作系统的工具包括 debuggers, trace analyzers, loggers and profilers。这些工具使开发人员能够使用各种调试技术，如打印调试（print debugging）、断点（breakpoints）、步进（stepping）和观察点（watchpoints）。

钩子断点

GDB执行，ebpf仅收集信息。

我们结合了二者，再把第一类的信息提取出来。这是一个新的工作。

调试器的主要功能是能够让使用者控制被调试软件的运行，并提供一系列工具实时查看被调试软件运行过程中的中间状态，为使用者定位程序问题以及修改代码提供帮助，是相关软件开发中不可缺少的一种工具。

GNU调试器（GDB）允许程序员查看被调试程序的运行状态、检查变量和内存、设置断点等，因此被广泛地用于调试操作系统[参考文献]。

在已有应用程序调试的基础上，增加了os调试功能。这样做的好处是，不需要对每一个被调试的操作系统进行逐一适配。 在操作系统的执行环境 “外部调试”，因为这样就不需要针对某一特殊OS。然而，不够完善，比如。因此，引入ebpf

when writing, focus on methodology

两种调试方法各有优缺点，

内部调试和外部调试方法的选择取决于多种因素，如所需的访问级别、所需的分析粒度以及目标平台兼容工具的可用性。每种方法都有自己的优势和局限性，选择时往往要在易用性、性能影响和获取相关数据的能力之间进行权衡。

使用这种方法可以让操作系统的开发与调试变得更加便捷。

并提供对调试过程的精细控制。另一方面，外部调试解决方案，如硬件调试器和仿真环境，独立于目标系统运行，提供非侵入式调试和剖析方法。

为了提高调试器的实用性，在支持GDB断点调试的基础上，我们又引入了eBPF、kprobe和uprobe等动态调试技术，实现了一种静态断点调试和动态跟踪结合的调试方法。我们实现了运行在操作系统中的eBPF与GDB的连接与交互，可以在运行时对内核进行监控，捕获有关函数执行等更多的信息。该方法支持GDB的静态断点调试，同时也支持使用eBPF对运行中的操作系统进行动态跟踪，可以对操作系统中运行的多个进程进行调试并获取更多函数信息。

## Rust 操作系统中基于 eBPF 的动态跟踪调试和基于 GDB 的静态断点调试的结合

### 概述

如上文所述，本文利用 QEMU 和 GDB 实现了对操作系统的跨特权级的调试和多进程的调试，但是单独使用GDB对操作系统进行调试仍然不够完善，具体来说，主要有以下几点。首先，GDB 对 Rust 语言的支持不够完善，这会影响 GDB 在 Rust 代码中的变量、数据结构和函数参数的查看以及堆栈跟踪的完整性。其次，GDB 静态断点调试需要暂停被调试操作系统的运行，无法在运行时动态地捕获操作系统中发生的事件。最后，GDB支持调试虚拟环境中的操作系统，但是调试真实环境中的操作系统比较困难。因此本文引入了eBPF、kprobe和uprobe调试技术，它们作为内核级别的调试工具，可以捕获并监视在操作系统中发生的事件，例如系统调用、中断等，允许用户在内核和用户程序运行时执行代码并监视系统级事件。kprobe和uprobe允许在操作系统运行时通过代码注入的方式动态设置断点，并且灵活捕获感兴趣的事件。我们希望将GDB静态断点调试功能和eBPF、kprobe和uprobe的动态跟踪功能结合到一起，这样能够对运行中的操作系统有更加全面的调试和监测。

因此，我们提出了出了一种静态断点调试和动态跟踪结合的方法，将GDB的多进程断点调试和基于eBPF的动态跟踪调试结合在一起。

### 实现

#### 移植 eBPF、kprobe、uprobe 到 rCore-Tutorial-v3

为实现基于eBPF的动态跟踪调试，我们首先移植了已有的 eBPF、kprobe 模块至目标操作系统 rCore-Tutorial-v3 中。考虑到用户常有将代码中出现的函数名，变量名等符号自动映射到对应的内存地址，并在其上设断点、观察点的需求，我们为 kprobe 模块添加了两种符号解析的实现。第一种是内核实现，即将符号表嵌入到被调试操作系统的内核中，并在内核中搜索符号对应的地址，这种实现方式的可移植性强，但是搜索符号时操作系统停止运行，因此效率比较低；第二种是外部实现，即将符号解析功能转移到了 VSCode 插件来实现，具体方法是通过VSCode插件调用宿主机上的的`nm`，`grep`等 Linux 命令将符号转换为地址。

由于 rCore-Tutorial-v3 上暂时没有成熟可用 uprobe 模块，我们将 [rCore-eBPF项目](https://github.com/hm1229/rCore-ebpf) ( 虽然名字类似，但是它和rCore-Tutorial-v3到代码完全不同） 中的紧耦合的 uprobe 代码改写成一个独立的模块（Rust Crate）并将这个模块移植到 rCore-Tutorial-v3 上。由于 rCore-Tutorial-v3 和 rCore 相比，各种功能的实现方式都有很大不同，两个 OS 提供的 API 也不尽相同，甚至，一部分 rCore 的 API 在 rCore-Tutorial-v3 里没有对应的实现，只能我们自己为 rCore-Tutorial-v3 编写。因此，uprobe 模块化和移植的工作量比较大。

## 展望

### 实际硬件的支持

我们已经完成了调试运行在qemu上的操作系统的工作。为了进一步测试调试器的功能，我们尝试将操作系统镜像烧录进真实硬件中，并实现调试功能。硬件方面我们使用的是昉星光2开发板，操作系统选用的是基于rust的操作系统Alien(作者：陈林峰)。

实现思路如下：首先通过cortex-debug或者命令行调试，实现对openocd的调试，然后再通过修改参数将openocd接入陈林峰的alien os的openocd接口 ，最后，将我们的code-debug替换第一步的调试手段。但是由于openocd不直接支持昉星光2这块板子，所以我们需要使用jtag来辅助openocd接入开发板并实现openocd对操作系统的调试功能。

目前已经实现了将Alien烧录进开发板并运行，但是由于时间等原因，暂未实现调试器的适配，这个是我们未来的工作之一。

### 软硬件结合的异常跟踪机制

我们的调试工具目前可以跟踪系统调用（syscall），但是无法有效跟踪异常（exception）。有一种新的解决方案，即通过修改虚拟机和真实硬件（例如作为 RISC-V 的一个扩展）来实现异常和系统调用的直接跟踪，提高调试工具的覆盖率和准确性。一旦发生异常或系统调用，硬件会直接通知外部调试器。外部调试器收到这个通知后，可以进行断点组切换等操作。

## 致谢

## 参考文献

[1] 前年发的那篇小论文
[2] ArceOS的链接
