# 支持Rust语言的源代码级操作系统调试工具

## 摘要

近年来，由于 RISC-V 的开源、简洁，Rust语言可以在不牺牲性能的情况下实现内存安全和对内存的精细化控制，基于 RISC-V 的 Rust 操作系统在学术界与产业界有大量的研究与开发工作。然而，研究人员或工程师在开发或调试相关代码时缺少一款适配的源代码级调试工具，使得开发过程艰难繁琐。传统的调试器，如 GDB 或 LLDB 不能很好地适应 RISC-V 上 Rust 操作系统的开发，因为在操作系统运行的过程中，会频繁地进行特权级的切换，导致调试信息丢失。而且，GDB 或 LLDB 对 Rust 语言的支持还不够完善，导致一些重要的调试信息无法获取到。为了解决这些问题，我们开发了 code-debug ，一个支持 Rust 语言的源代码级操作系统调试工具。它可以提供基于 QEMU 和 GDB 的跨特权级的源代码跟踪调试，支持同时调试内核和多个用户态进程，且支持同时使用 GDB 断点和 eBPF 来收集调试数据。

关键词：Rust操作系统；操作系统调试器；多进程调试；GDB；eBPF

## 1 Introduction 概述

操作系统（OS）是驱动硬件运行的核心系统，其在硬件和用户之间起到了桥梁的作用。包括基于 C 语言以及基于 Rust 语言的操作系统内核代码调试一直是开发人员面临的技术难点。不同于通用应用程序代码调试，操作系统源代码运行状态多、工作逻辑复杂，使得传统的调试方法难以适应其开发调试工作。因此，方便的源代码级调试工具，对监测程序运行状态和理解程序的逻辑十分重要，尤其是相对复杂的内核代码以及用户态、内核态的系统调用交互。

操作系统运行状态一般分为用户态和内核态，属于两个不同的特权级，拥有不同的执行权限。当应用程序需要执行一些特权操作或与操作系统交互时，它需要通过系统调用的方式从用户态切换到内核态。特权级的应用提供了应用程序与内核之间的隔离，可以有效防止应用程序对操作系统造成损害，并优化系统的资源利用。但另一方面，特权级的切换会清除调试状态信息，使得传统程序调试方法失效。为应对此问题，我们提出了一种名为“断点组切换”的机制。该机制的核心思想是将用户设置的 GDB 断点根据它们所在的地址空间分为不同的组，确保在任一给定时刻，只有与当前地址空间相关的断点组处于激活状态。当地址空间发生变化时，调试器会自动切换到新的地址空间对应的断点组和符号表，从而保证了不同特权级代码的断点均能有效触发。实施该机制面临的主要挑战包括如何快速检测到地址空间的切换，以及在操作系统动态运行的时候如何实现断点组和符号表的实时切换。鉴于 GDB 在大多数情况下用于静态调试，即只在被调试的操作系统因断点触发而暂停后才能设置新的断点或切换符号表，这一动态调试的需求导致了更大的复杂性。

除此以外，操作系统需要运行在一个指定的硬件环境中，所以调试方式和普通应用程序的调试方式有所不同。在调试普通应用程序时，调试器和被调试应用程序运行于同一执行环境（即操作系统）中，调试器利用执行环境提供的接口，控制被调试应用程序的运行并实时查看其运行过程中的中间状态。在调试操作系统时，有两种方法：一种是通过修改操作系统源代码，将调试器集成在操作系统的内核中，比如 Linux 的 kprobe[参考文献]，KDB[参考文献]，我们称这种方法为“内部调试”；另一种是利用操作系统的执行环境的调试接口，让运行于操作系统执行环境以外的调试器通过该调试接口进行操作系统的调试。（注：如果解释不清楚，可以增加插图）例如，QEMU（一个完全由软件实现的开源虚拟机，可以提供操作系统运行所需的硬件执行环境）允许运行在宿主机中的 GDB 调试器利用 QEMU 的 GDBStub 调试接口[参考文献]，调试正在运行于其中的操作系统[参考文献]。我们称这种方法为“外部调试”。考虑到这两种操作系统调试方法可以互补，我们的调试器同时使用上述两种调试方法调试操作系统。如下图（注：增加插图）所示，我们的调试器利用 Qemu 的 GDBStub 接口进行外部调试（调试器在进行外部调试时通过断点组切换功能可以进行跨特权级 GDB 断点调试），与此同时调用被调试操作系统的 kprobe、uprobe 功能进行内部调试，利用 eBPF 收集调试信息并输出到调试器。

一些调试插件可以将 VSCode，Vim，EMACS 等代码编辑器变为 GDB 的继承调试环境。这些继承调试环境不仅能够更方便地展示调试信息，而且提供了一些能够简化使用流程的自动化功能，所以对于代码开发和调试有很大帮助。我们在 VSCode 调试插件 Native Debug[VSCode商店链接] 的基础上实现了我们设计的两个调试功能（断点组切换和内部、外部调试结合）和这两个功能的图形界面，从而所有的调试功能都被集成在同一个调试环境里，方便用户使用。

总之，本论文所作出的贡献可以被总结为（The contributions of this paper can be summarized as follows）：

- 提出一种断点组切换的机制，从而提供基于GDB的跨内核态、用户态断点调试功能.
- 提出一套通用的在内核中获取下一个进程名，并根据进程名切换符号表的机制，从而支持同时调试内核和多个用户态进程
- 基于VSCode，提供一套支持同时用 GDB 和 eBPF 进行调试的远程开发调试环境。

## 2 Motivation 动机

上述这些调试器对操作系统源代码的调试支持不够完善，其中一个主要问题在于操作系统不同运行状态下程序符号表的切换导致断点等调试信息丢失，从而使得调试器失效。

首先，操作系统中包括用户态代码和内核态代码，对应不同的特权级，不同的特权级又对应不同的符号表。在操作系统运行的过程中，会频繁地进行特权级的切换，导致调试信息的丢失，而目前现有的调试器都无法进行跨特权级的断点调试。具体来说，特权级的切换主要涉及符号表的切换，符号表包含了编译后的代码中各种变量、函数、数据结构等的名称和地址信息，这些是调试代码所必需的内容，同时符号表也是编译后的代码与源代码之间的桥梁，使调试器能够将二进制代码中的地址映射回源代码的符号名，所以无论调试任何进程，调试器都需要先加载进程的符号表。而在操作系统中内核态程序和用户态程序的符号表是分开的，如果程序运行中进行了用户态和内核态的转换，符号表也要随之切换，符号表切换以后，用户设置的程序断点也会随之消失，比如在内核态设置用户态的断点以后，再进入用户态，用户态的断点将不会被触发。

其次，用户态中的多个用户进程分别对应不同的符号表，在CPU对用户进程进行调度切换运行状态时同样存在上述的调试信息失效的问题。如何解决操作系统中多符号表切换导致的调试信息失效是我们解决的关键问题。

QEMU自带的GDB工具可以对操作系统进行静态断点调试，如上文所述，本文实现了对操作系统的跨特权级的调试和多进程的调试，但是单独使用GDB对操作系统进行调试仍然不够完善，具体来说，主要有以下几点。首先， GDB 对 Rust 语言的支持不够完善，不如像C/C++ 语言的编译器在生成调试信息方面成熟，Rust语言的调试信息可能不如 C/C++ 语言的那么详细，这会影响 GDB 在 Rust 代码中的变量和数据结构查看以及堆栈跟踪的质量。其次，GDB 静态断点调试需要暂停被调试操作系统的运行，无法在运行时动态地捕获操作系统中发生的事件，无法查看函数调用参数等。最后，GDB支持在虚拟环境中进行调试，如果Rust操作系统需要运行在真实环境中，并投入生产的时候，单独的GDB调试无法满足调试需求。因此本文引入了eBPF和kprobe两种调试技术，它们作为内核级别的调试工具，可以捕获并监视在操作系统内核中发生的事件，例如系统调用、中断等，允许用户在内核运行时执行代码并监视系统级事件。kprobe还允许在运行时通过代码注入的方式动态设置断点，并且灵活捕获感兴趣的事件。本文希望将GDB静态断点调试功能和eBPF、 kprobe的动态跟踪功能结合到 一起，这样能够对运行中的操作系统有更加全面的调试和监测。

## 3 Approach 方法

### A. Overview 概述

### B. 跨特权级源代码断点设置

由于操作系统中内核态代码和用户态代码的符号表是分开，在操作系统切换特权级的时候，符号表也会切换，使得断点等调试信息失效，因此同时设置内核态、用户态的断点会产生冲突，无法跨越特权设置断点。为了解决这个问题，我们新增了一个断点组管理模块。断点组管理模块会先缓存设置的异常断点（例如当前操作系统处在内核态代码的运行中，操作人员在用户态代码中设置了断点，该断点即为异常断点），等到特权级切换到对应的状态时，再将缓存的断点信息进行激活，即在用户态运行时，缓存用户设置的内核态断点，等到程序运行到内核态时，再激活缓存的内核态断点；在内核态运行时，缓存用户设置的用户态断点，等运行到用户态时，再激活用户态断点。通过这种方法，操作人员可以在任意状态下对被调试操作系统的任意代码行设置断点，从而实现跨特权级的源代码调试。

### C. 多个用户进程符号表切换

操作系统通常允许在用户态创建多个进程对应不同的工作，即用户进程，多个用户进程会抢占有限的中央处理器运行资源，即调度执行或用户进程切换。类似于用户态与内核态，每个用户进程都有自己的符号表，每次进行用户进程切换的时候都需要通过系统调用进入内核态，更新内存地址空间，然后返回用户态执行新的进程。我们设计了通过进程标识的获取对应不同的符号表，并在调试器检测到用户程序切换时对符号表进行切换，以此实现多用户进程的调试。

### D. GDB 静态断点调试和 eBPF 动态跟踪结合

我们设计的静态断点调试和动态跟踪结合的方法分为三个主要步骤：调试行为执行、两种调试信息的整合和两种调试信息的联合展示。

在调试行为执行阶段，我们除了通过 QEMU 已有的 GDB 调试机制进行静态断点调试之外，增加了通过eBPF技术进行动态跟踪调试的机制。我们在被调试OS内新增一个用于进行eBPF调试的进程，这个进程通过一个专用的调试信息通道（可以是串口或网络），接收从宿主机发来的调试命令，并且解析、执行调试命令。

在调试信息整合阶段，我们需要将不同来源的调试信息进行整合。整合的第一步是将两个调试信息通道的信息传输到同一个地方。第二步是根据调试信息的标识符，确定调试信息的类型，并根据不同的类型发送给用户界面中负责视觉呈现的不同模块。

在信息呈现阶段，我们利用VSCode已有的各种视觉组件（widget），提供直观的调试反馈。

## 4 Implementation 实现

### A. 解决跨特权级源代码断点设置问题

设置断点组数据结构，用于保存因为特权级切换失效的断点调试信息：使用一个词典缓存了用户要求设置的所有断点（包括内核态和用户态）。词典中的每个元素都是一个键值对，其中键是程序运行所占内存地址空间的代号，值是该代号对应的断点组，包括用户态断点组和内核态断点组，分别保存了用户态和内核态对应内存地址空间内的所有断点。除此以外，为了满足调试需求，设置了一个当前有效断点组变量，即被调试操作系统当前执行的进程地址空间对应的断点组，只有当前有效断点组中的断点才会被激活，随后会被触发，不是当前有效断点组的断点只会被缓存到其他地址空间的断点组中，不会被触发。

当用户在调试器中设置新断点时，调试器的断点组管理模块会先将这个断点的信息存储在对应的断点组中，然后判断这个断点所在的断点组是否为当前有效断点组。如果是，就立即激活这个断点。如果不是，那么这个断点暂时不会被激活，将会被保存到断点组中。在这种缓存机制下，用户态断点和内核态断点不会同时被激活，从而避免了内核态和用户态断点的冲突。

调试器检测到被调试操作系统的特权级切换：通过人工分析找到被调试操作系统的用户态和内核态切换的边界代码位置，并设置检测点。当操作系统运行到边界检测点时说明马上就会进行特权级的切换，此时调试器自动中断操作系统的运行，并进行对应符号表的切换以及断点组的切换，最后恢复操作系统的运行。如下图所示，当用户进程A想要通过系统调用进入内核态时，会触发边界检测点，这时调试器就会检测到被调试操作系统发生了特权级切换，接下来就会进行符号表切换、断点组切换，在切换过程中，调试器会删除原进程对应的地址空间中设置的断点，设置新进程地址空间中断点组的断点，从内核态回到用户态也是一样的流程。边界监测点不属于任何断点组，如果设置了边界监测点，就会立即被激活然后等待被触发。

![特权级切换示意图](./images/privilege-change.png)
特权级切换示意图

如下面流程图所展示的，操作者需要先找到边界监测点的位置，并进行配置，随后就可以启动调试。在调试过程中，被调试操作系统启动以后会先进入内核态，接着被调试操作系统继续运行，会暂停到边界监测点的位置，这时用户就可以在源代码的任意位置设置断点，但是只有内核态中的断点会被激活，随后被触发，最后会暂停到内核出口检测点的位置，调试器进行符号表和断点组的切换。接下来就会进入指定的用户进程，该用户进程中的所有断点都被激活，并暂停到用户进程中设置的第一个断点，在用户进程中，用户可以通过设置好的调试选项，在任意时刻进入内核态，在这个过程中，用户可以在任意时刻、任意代码行设置断点，观测各种变量信息，最终完成整个操作系统的调试。

![调试器配置、使用流程图](./images/debugger-config-and-usage-flowchart.png)
调试器配置、使用流程图

通过断点组对断点的缓存机制，用户可以在被调试操作系统任意特权级下的任意代码中设置断点，这些断点都会被保存，只有操作系统运行到某个进程的时候，相应的地址空间中的断点组的断点才会被激活，最终被触发，从而解决了跨特权级源代码断点设置的问题。

### B. 解决多个用户进程符号表切换的问题

获取进程标识符：调试器是根据进程标识符，来进行符号表切换的，我们在调试器中使用一个变量来保存被调试进程的标识符。在操作系统中，切换用户进程都需要经过系统调用进入内核态，在内核态中可以获取到下一个运行的进程标识符。操作者需要在被调试操作系统的内核态源代码中，含有进程标识符变量的代码行设置断点，如sys_exec函数中，通过给GDB发送获取变量信息的命令，并解析返回信息，来获取进程标识符。

多个用户进程切换符号表：在被调试操作系统刚刚运行起来的时候都是先从内核态开始运行的，然后会指定一个第一个要运行的用户态进程，如用户进程A，在调试器触发边界检测点的时候，调试器就会根据用户进程A的进程标识符进行符号表的切换，切换到指定的用户进程A的符号表，切换断点组，激活在用户进程A中设置的断点。接下来要进行进程切换的话，就需要从当前进程A进入内核态，当边界检测点被触发时，切换到内核的符号表，切换断点组，在内核态运行的时候，获取到下一个要执行的用户进程标识符，如用户进程C。在获取到用户进程C的标识符以后，赋值给保存进程标识符的变量，这样调试器就能够知道下一个要运行的进程是用户进程C。接下来从内核态进入用户态，在边界检测点进行符号表切换，此时要切换的符号表就是用户进程C的符号表，断点组切换，激活用户进程C中设置的断点，最终实现了多个用户进程的符号表切换，如下图所示。

### C. 基于VSCode，提供一套支持同时用 GDB 和 eBPF 进行调试的远程开发调试环境

#### 调试行为执行

QEMU 提供了 GDBServer（这个 GDBServer 叫做 GDBStub）用于GDB断点调试功能。我们决定模仿这个方法，在被调试的操作系统内运行一个GDBServer（我们称之为eBPF Daemon），它接收从调试信息通道传来的调试命令，并根据调试命令进行注入eBPF程序、kprobe和uprobe插桩等操作。当操作系统中某个事件触发，事先注入的eBPF程序会执行。一般eBPF程序会将收集到的调试信息存储于eBPF maps中，但是由于我们的调试器在操作系统之外，这样的存储的步骤显得没有必要。因此我们的eBPF程序会直接通过helper function将收集到的调试信息通过专用调试信息通道输出。

实现这个 eBPF Daemon 的工作量不大，但是实现调试信息通道繁琐得多。由于我们想调试的 rCore-Tutorial-v3 操作系统并无稳定的网络协议栈可用，我们选择使用专用的串口作为调试信息输入输出的通道。但是 rCore-Tutorial-v3 本身的终端输出就占用了一个串口，且当前版本的 qemu-system-riscv64 不支持多个串口。为了支持多个串口，我们除了在 rCore-Tutorial-v3 中添加了支持基于MMIO的多串口输入输出外，还修改了 QEMU 的初始化代码、SBI的PMP设置。

#### 调试信息整合

GDB 进程会通过一个串口与 GDBStub 用 RSP 协议通信。我们通过 GDB 的 Python 脚本功能，启动了一个线程，这个线程通过另一个串口与 eBPF Daemon 同样用 RSP 协议通信。当 eBPF Daemon返回了调试信息，这个线程会将从eBPF Daemon获得的动态调试信息转换为GDB/MI命令，用 与从GDBStub获得的静态调试信息一样的传送方式 发送给 VSCode 的 Debug Adapter。从而实现了一个GDB同时连接两个GDBServer，且这两个 GDBServer 跟踪的是同一个目标（target）。这种方案的好处是，Debug Adapter 和 GDB 的交互接口（interface）仍然保持统一。

在实现这个功能的过程中，我们注意到一个现象，eBPF Daemon 的一些调试消息会打断正在发送的另一条消息。我们将这种有抢占特性的消息赋予一个独特的消息头，遇到这种“抢占消息”时进入一个新处理流程，处理完之后再回来处理原来的消息，从而规避了这个问题。

#### 调试信息展现

Debug Adapter 接收到 GDB 传来的动态、静态调试信息后，通过辨识调试信息里的标识符，判断这条调试信息的类别，并根据调试消息的类别将调试信息传送到VSCode中对应的组件中进行展示。这样，我们提供了直观的调试反馈，提高了调试效率和用户体验。我们为所有静态、动态调试的功能都制作了用户界面：

![oslab-2023-08-14-15-37-16](./assets/oslab-2023-08-14-15-37-16.png)
图 eBPF调试界面

![多个用户进程的符号表切换示意图](./images/multiple-user-processes-symbol-table-change.png)
多个用户进程的符号表切换示意图

调试器通过在内核态给GDB发送指定命令来获取到下一个要运行的进程标识符，获取到以后调试器就可以根据该标识符切换到正确的用户进程中，并对新进程进行调试。

## 5 Related Work 相关工作

待搜：kprobe uprobe ebpf

### 内部调试

1. 内核级调试器（kernel-level debuggers）： 内核级调试器集成在操作系统中，可直接访问内核的内部数据结构和函数。这些调试器允许开发人员设置断点、检查内存并逐步执行内核代码。内核级调试器的例子包括 Linux 内核调试器（KGDB）和 Windows 内核调试器（WinDbg）。

2. 跟踪工具（Tracing facilities）：操作系统通常包含内置跟踪设施，可以收集运行时信息，而无需进行侵入式调试（intrusive debugging）。这些工具可捕获函数调用、系统调用和中断等事件，并将其存储在缓冲区或日志文件中，以供日后分析。Linux Trace Toolkit (LTT) 和 Windows Event Tracing for Windows (ETW) 等工具就属于这一类。

3. 性能监控单元（PMU）： PMU 是收集性能相关数据的硬件组件，如 CPU 周期、缓存未命中和分支预测错误等。操作系统可以通过软件接口公开 PMU 数据，使开发人员可以对应用程序进行剖析和优化。Linux perf 工具和 Windows 性能分析器就是利用 PMU 数据进行性能分析的工具。

### 外部调试

1. 模拟环境： 模拟环境为运行和调试操作系统提供了一个虚拟平台，无需物理硬件。这些环境模拟目标系统的执行环境，包括处理器、内存和外围设备，并允许开发人员控制目标系统的执行、检查系统状态和模拟各种情况。King S T, Dunlap G W, Chen P M. developed a time-traveling virtual machine that enables a programmer to navigate backward and forward arbitrarily through the execution history of a particular run and to replay arbitrary segments of the past execution.[1]. Cagnin F. developed LLDBagility, a tool to enable kernel debugging via virtual machine introspection，to improve the overall debugging experience for the macOS kernel[4].

2. 硬件调试器：硬件调试器是通过调试端口（如 JTAG 或 SWD）连接到目标系统（target system）的外部设备。这些调试器可直接访问处理器的寄存器和内存，从而实现底层调试并控制执行流程。硬件调试器通常用于裸机调试（bare-metal debugging），也可与 OpenOCD 等软件调试器结合使用，以获得更全面的调试体验。

3. 仪器框架（Instrumentation frameworks）： Instrumentation of a software system is a technique for inserting extra code into an application to observer its behavior. Melvin S W, Patt Y N. developed a tool based on microcode modifications to a VAX 8600 which allows a wide variety of operating system measurements to be taken with minimal perturbation and without the need to modify any operating system software. [2]

## 6 Conclusion 结论

我们设计并实现了一种支持跨内核态和用户态的操作系统源代码调试方法，在该方法中，我们设置了断点组管理模块，缓存用户设置的不在当前进程地址空间的断点，并在被调试操作系统运行到对应的地址空间的时候再激活断点，实现断点组的切换，解决了跨特权级的源代码断点设置冲突的问题；其次设置了边界检测点，使调试器能够识别被调试操作系统当前在哪个特权级中运行，并根据特权级切换不同的符号表，从而能够让使用者进行跨特权级的调试；最后为了支持多个用户进程的调试，我们在内核代码中获取下一个要运行进程的标识符，并告知调试器，调试器根据进程标识符来确定下一个要切换的符号表，获取到新进程的调试信息，对新进程进行调试，也能够支持多个用户进程的符号表切换，从而实现了对多个用户进程的调试。

其次，我们...

## 7 Reference 参考文献

[1] King S T, Dunlap G W, Chen P M. Debugging operating systems with time-traveling virtual machines[C]//Proceedings of the 2005 USENIX Technical Conference. 2005: 1-15.

[2] Melvin S W, Patt Y N. The use of microcode instrumentation for development, debugging and tuning of operating system kernels[C]//Proceedings of the 1988 ACM SIGMETRICS conference on Measurement and modeling of computer systems. 1988: 207-214.

[3] Högl H, Rath D. Open on-chip debugger–openocd–[J]. Fakultat fur Informatik, Tech. Rep, 2006.

[4] Cagnin F. LLDBagility: practical macOS kernel debugging[J]. 2020.