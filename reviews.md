# 论文修改意见

## 11月21日 - wjb

1. ✅ 概述：动机并不是开发者希望用“GDB”等调试器来同时调试内核和用户态，而是需要进一步分析原生的问题，比如：在调试基于系统调用等操作系统强相关的程序时，已有的调试器无法对操作系统内部的函数调用进行进一步跟踪。主要面临的问题在于xxxx。
2. ✅ “操作系统在特权级切换时会进行页表的切换，进而导致断点调试信息丢失，从而导致调试失败”，需要先解释什么叫做特权级，什么叫做特权级切换？页表的切换是否核心的原因？改成符号表等其他调试信息切换是否更合适？
3. ✅ 断点组是你提出来的方法，而不是“利用”。每次在出现新名词的时候前面都要先介绍。
4. ✅ 第2节标题是动机，但你实际写的内容是问题的展开描述
5. ✅ “假设一位开发者正在用 GDB 调试一个操作系统”，需要描述清楚到底是什么样的场景，比如调试操作系统内核模块时不存在你这里描述的这些问题
6. ✅ 2节中最后写的一大段解决方法要放到第3节中写，这里只要简单一两句话提一下。具体的写法建议去参考已有文章的写法和结构
7. ✅ 第3节“方法”，这个标题的写法最好去参考一下别人的文章中是怎么取的标题。
8. ✅ “将介绍实现该模块的方法”方法是方法，实现是实现，这是两码事，不要混为一谈
9. 在写方法之前需要有相关工作，实验
10. 第3节需要以总分总的形式来组织，分小节描述核心问题，并且需要补图
11. 第4节，实现部分应该要从总体角度先分析框架，再写具体核心模块的实现，并且要补充例子

## 12月4日 - czy

上下文切换来的 灵感 （先介绍一下上下文切换，其中就涉及到页表切换和特权级切换，刚好能引出下文）

虽然断点不行，但是在一定条件下可以单步过去。
断点 作用域
本质上还是符号表的问题

先说符号表：没符号表根本就无法设置源代码断点。

就算加载符号表，由于页表的问题，断点也无法跨特权级设置。

第二章补充：我们将在第二章中说明，这些互相独立的符号表即使同时被调试器加载，也无法进行跨隔离环境的断点设置。

每个符号表有作用域，一个执行环境对应一个符号表，之前是因为可以共存符号表，没想过来。

先说不能跨特权级设置。后面具体分析。

解决方案可以先说怎么找到并替换合适用户符号表的问题，毕竟这个问题简单直接一点。然后引出解决方案钩子断点，这个就可以放在前面说了，减小后面累赘的内容。钩子断点要解决的是符号表的问题，之前没注意过

结构清晰之后就可以多加小标题了，后面的一些修改意见就可以自然地满足

之前好像看到一个讲断点原理的论文，90年代的，可以引用到相关工作里面

**符号表必须要在当前地址空间下才能正常运作**，除非能弄出一种“内核态视角的用户符号表”，就是把用户虚拟地址转换成物理地址再转换成内核虚拟地址。就算直接设置内存地址断点，第二章中也将证明，页表的切换也会导致同样的问题，因此也不行（除非把用户态地址转换成内核地址空间的）。

写不出来的时候可以先删掉一些重复的内容

此外，用户可能不知道要加载哪个用户符号表。

之前文件的说法是“切换后之前的断点消失”，现在改说“切换前不能设置切换后的断点”

相关工作加完之后要把introduction里面的“第二章”改成"第三章"

因此，当用户试图在设置跨隔离环境的断点，他将面临这样的难题：没符号表，也因此无法设置源代码断点。

好，我现在开始听写，就是写字写不出来，然后我突然看到我之前卡在的地方是那个那个自己的工作内容的部分符号表的那个部分的已经写了OK了，工作内容部分部分其实不用卡的，因为这个部分已经告诉我答案了，我就照着他的意思写就行，而且这个东西就放在的那个摘要摘要前面，我之前都忘记去看了。

我们通过以下两个核心方法来实现这一思路。首先，用户需提供一组规则，用于将源代码文件映射至对应的断点组，从而在调试过程中为每个断点确定其所属断点组。随后，根据另一组映射规则，将断点组关联到相应的符号表文件路径。借此，调试器在接收到用户断点设置命令时，可根据当前隔离环境自动决定是否立即设置该断点，或是先将其缓存，待下次上下文切换后再行设置。

其次，为了在运行时准确检测并应对隔离环境（特权级、页表）的切换，我们在特权级切换的边界位置设置了出口断点（boundary breakpoints）。当出口断点被触发时，调试器据此判断操作系统即将离开当前隔离环境；接下来，调试器通过数次单步执行，确保新页表切换完成后再卸载旧断点组与符号表，并加载新隔离环境所需的断点组和符号表。这确保了断点与符号表的更新恰好发生在合适的时机，从而实现无缝切换与正确的断点触发。

其实这样的就是第一个就是你怎么检测到你那个你的这个隔离环境的切换，那至少我们想到了我们用一个特殊的断点这个特殊断也需要用户事先在配置文件里面指定，但是调试机会自动去设定那这种特殊锻炼处罚就表示着这个这个隔离环境要离开了，要跑到下一个隔离环境，那我们怎么确定下一个隔离环境是什么呢？那我们就要用前面那个公司断？就是第二工作你怎么检测到他就有用户人工去设定一个出我这第一个工作，然后第二个工作的是切换时的调试信息切换就说你这个这个断点卸载，然后还有那个，然后怎么检测到我们已经单不到了，新的那个新的一个隔离环境，然后又为什么要干部为什么不能直接用断点跳过去，然后怎么卸载和那个加载一个顺序应该是什么这些细节问题，就是第二个就是切换者的调试信息切换的问题

第二个核心方法是通过边界断点进行特权级切换检测，从而能够在隔离环境切换时进行调试信息的切换（以及切换时的调试信息切换）。如前文所述，调试器不能识别到隔离环境的切换。那如何让操作系统的调试器识别到隔离环境的切换，并且进行断点组的切换？我们想到的办法是，毕竟切换断点和符号表只能在调试器暂停下来的时候才行。核心工作：人工设置出口断点，调试器读取并自动打边界断点，触发之后识别并切换断点组。页表切换之后将调试器加载的符号表替换为新隔离环境的符号表。第二个是怎么切换。断点不行，可以单步。工程上的难点是怎么通过单步过去。只有一种GDB可以单步。

## code compare

### mi2.ts

- get register names and values
- add index to outputs

### frontend/extension.ts

- register buttons and webviews

### OSStateMachine.ts

- define debugger behavior

### gdb.ts

- copy launch.json into GDBDebugSession

### mibase.ts

- hook breakpoint
- breakpoint group
    - border
    - breakpoint groups
    - stop handlers -> osevent.stopped
    - cache breakpoints at set breakpoints request
- doAction