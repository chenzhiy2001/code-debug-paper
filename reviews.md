# 论文修改意见

## 11月21日 - wjb

1. ✅ 概述：动机并不是开发者希望用“GDB”等调试器来同时调试内核和用户态，而是需要进一步分析原生的问题，比如：在调试基于系统调用等操作系统强相关的程序时，已有的调试器无法对操作系统内部的函数调用进行进一步跟踪。主要面临的问题在于xxxx。
2. ✅ “操作系统在特权级切换时会进行页表的切换，进而导致断点调试信息丢失，从而导致调试失败”，需要先解释什么叫做特权级，什么叫做特权级切换？页表的切换是否核心的原因？改成符号表等其他调试信息切换是否更合适？
3. ✅ 断点组是你提出来的方法，而不是“利用”。每次在出现新名词的时候前面都要先介绍。
4. ✅ 第2节标题是动机，但你实际写的内容是问题的展开描述
5. ✅ “假设一位开发者正在用 GDB 调试一个操作系统”，需要描述清楚到底是什么样的场景，比如调试操作系统内核模块时不存在你这里描述的这些问题
6. ✅ 2节中最后写的一大段解决方法要放到第3节中写，这里只要简单一两句话提一下。具体的写法建议去参考已有文章的写法和结构
7. ✅ 第3节“方法”，这个标题的写法最好去参考一下别人的文章中是怎么取的标题。
8. ✅ “将介绍实现该模块的方法”方法是方法，实现是实现，这是两码事，不要混为一谈
9. 在写方法之前需要有相关工作，实验
10. 第3节需要以总分总的形式来组织，分小节描述核心问题，并且需要补图
11. 第4节，实现部分应该要从总体角度先分析框架，再写具体核心模块的实现，并且要补充例子

## 12月4日 - czy

现在首要的问题是，我们如何判断出什么样的断点是属于当前页表的。

断点组管理模块就应当从用户设置断点的命令中的信息来解析出这个断点所对应的页表。（让用户自己去设置的原因是，这玩意没有固定的规则），

上一章我们提到我们要用一个断点组管理模块来进行断点的管理，进而实现只在当前页表下设断点，这样就可以保证不出现上一章所述的双页表 OS 跨特权级设断点及单页表 OS 跨进程设断点时出现的问题。

上下文切换来的 灵感 （先介绍一下上下文切换，其中就涉及到页表切换和特权级切换，刚好能引出下文）

虽然断点不行，但是在一定条件下可以单步过去。
断点 作用域
本质上还是符号表的问题

先说符号表：没符号表根本就无法设置源代码断点。

就算加载符号表，由于页表的问题，断点也无法跨特权级设置。

第二章补充：我们将在第二章中说明，这些互相独立的符号表即使同时被调试器加载，也无法进行跨隔离环境的断点设置。

每个符号表有作用域，一个执行环境对应一个符号表，之前是因为可以共存符号表，没想过来。

先说不能跨特权级设置。后面具体分析。

解决方案可以先说怎么找到并替换合适用户符号表的问题，毕竟这个问题简单直接一点。然后引出解决方案钩子断点，这个就可以放在前面说了，减小后面累赘的内容。钩子断点要解决的是符号表的问题，之前没注意过

结构清晰之后就可以多加小标题了，后面的一些修改意见就可以自然地满足

之前好像看到一个讲断点原理的论文，90年代的，可以引用到相关工作里面

**符号表必须要在当前地址空间下才能正常运作**，除非能弄出一种“内核态视角的用户符号表”，就是把用户虚拟地址转换成物理地址再转换成内核虚拟地址。就算直接设置内存地址断点，第二章中也将证明，页表的切换也会导致同样的问题，因此也不行（除非把用户态地址转换成内核地址空间的）。

写不出来的时候可以先删掉一些重复的内容

此外，用户可能不知道要加载哪个用户符号表。

之前文件的说法是“切换后之前的断点消失”，现在改说“切换前不能设置切换后的断点”

因此，当用户试图在设置跨隔离环境的断点，他将面临这样的难题：没符号表，也因此无法设置源代码断点。

好，我现在开始听写，就是写字写不出来，然后我突然看到我之前卡在的地方是那个那个自己的工作内容的部分符号表的那个部分的已经写了OK了，工作内容部分部分其实不用卡的，因为这个部分已经告诉我答案了，我就照着他的意思写就行，而且这个东西就放在的那个摘要摘要前面，我之前都忘记去看了。

我们通过以下两个核心方法来实现这一思路。首先，用户需提供一组规则，用于将源代码文件映射至对应的断点组，从而在调试过程中为每个断点确定其所属断点组。随后，根据另一组映射规则，将断点组关联到相应的符号表文件路径。借此，调试器在接收到用户断点设置命令时，可根据当前隔离环境自动决定是否立即设置该断点，或是先将其缓存，待下次上下文切换后再行设置。

其次，为了在运行时准确检测并应对隔离环境（特权级、页表）的切换，我们在特权级切换的边界位置设置了出口断点（boundary breakpoints）。当出口断点被触发时，调试器据此判断操作系统即将离开当前隔离环境；接下来，调试器通过数次单步执行，确保新页表切换完成后再卸载旧断点组与符号表，并加载新隔离环境所需的断点组和符号表。这确保了断点与符号表的更新恰好发生在合适的时机，从而实现无缝切换与正确的断点触发。

其实这样的就是第一个就是你怎么检测到你那个你的这个隔离环境的切换，那至少我们想到了我们用一个特殊的断点这个特殊断也需要用户事先在配置文件里面指定，但是调试机会自动去设定那这种特殊锻炼处罚就表示着这个这个隔离环境要离开了，要跑到下一个隔离环境，那我们怎么确定下一个隔离环境是什么呢？那我们就要用前面那个公司断？就是第二工作你怎么检测到他就有用户人工去设定一个出我这第一个工作，然后第二个工作的是切换时的调试信息切换就说你这个这个断点卸载，然后还有那个，然后怎么检测到我们已经单不到了，新的那个新的一个隔离环境，然后又为什么要干部为什么不能直接用断点跳过去，然后怎么卸载和那个加载一个顺序应该是什么这些细节问题，就是第二个就是切换者的调试信息切换的问题

第二个核心方法是通过边界断点进行特权级切换检测，从而能够在隔离环境切换时进行调试信息的切换（以及切换时的调试信息切换）。如前文所述，调试器不能识别到隔离环境的切换。那如何让操作系统的调试器识别到隔离环境的切换，并且进行断点组的切换？我们想到的办法是，毕竟切换断点和符号表只能在调试器暂停下来的时候才行。核心工作：人工设置出口断点，调试器读取并自动打边界断点，触发之后识别并切换断点组。页表切换之后将调试器加载的符号表替换为新隔离环境的符号表。第二个是怎么切换。断点不行，可以单步。工程上的难点是怎么通过单步过去。只有一种GDB可以单步。

## code compare

### mi2.ts

- get register names and values
- add index to outputs

### frontend/extension.ts

- register buttons and webviews

### OSStateMachine.ts

- define debugger behavior

### gdb.ts

- copy launch.json into GDBDebugSession

### mibase.ts

- hook breakpoint
- breakpoint group
  - border
  - breakpoint groups
  - stop handlers -> osevent.stopped
  - cache breakpoints at set breakpoints request
- doAction

## 2 相关工作

本章聚焦于调试器断点与符号表的基本原理，为后文的跨特权级、多进程调试方案奠定概念基础。

### 2.1 调试器中的断点与单步

现代调试器（如 GDB 或 LLDB）通常通过**指令替换**来实现软件断点（software breakpoint）。具体来说，当用户在某行源代码上设置断点时，调试器会先将该行对应的机器指令（例如 `add x0, x0, x0`）在内存中替换为一个特殊的中断指令（例如在 x86 上是 `INT 3`，在 RISC-V 上是 `EBREAK`）。一旦处理器执行到这条特殊指令，便会触发调试器捕获并暂停程序，从而实现断点功能。

与断点触发相对应的**单步执行**则是指调试器指令级地让被调试程序只执行一条或几条机器指令后再次暂停。实现单步的方式主要依赖处理器或仿真器提供的“单步”硬件功能（如 x86 的 TF 标志位或 RISC-V 的 `stepie`），或者在软件层面模拟执行并在每个指令后主动暂停。当某些代码位置无法正确设断点（例如关键的上下文切换点）时，**单步执行**往往能“绕过”断点失效问题，继续逐条观察程序状态。因此，在操作系统或嵌入式场景中，调试器通常结合断点与单步来定位和解决问题。

### 2.2 符号表

**符号表**是将源代码中的符号（如变量名、函数名等）映射到程序运行时地址空间（虚拟地址）的数据结构。编译器或链接器在生成可执行文件（如 ELF 文件）时，会将源文件中的符号和相应的虚拟地址记录在符号表中。调试器在加载可执行文件后，通常会读取这些符号与地址的映射关系，从而支持“按源代码级别”设置断点、查看变量值等高级功能。

对于操作系统调试而言，不同特权级或不同进程常拥有独立的地址空间及符号表。当内核与用户进程各自对应不同的符号表时，若调试器需要跨特权级或跨进程设置断点，就必须在恰当的时机切换并使用正确的符号表，否则调试器无法定位目标指令或数据地址。

---

*可视情况在后续章节引入更多与交叉调试、远程调试接口（JTAG、OpenOCD 等）以及其他参考文献相关的讨论。*

### 实现总体框架

- 修改 Native Debug 插件

### 核心功能模块

#### 断点组管理模块

首先要考虑的问题是断点组管理模块中的数据结构。我们用一个词典保存所有的断点组。词典中某个项（entry）的键是断点组的名字，值是一个数组，其中包含了属于该断点组的所有断点的信息。


#### 上下文状态机

### 示例：跨特权级、多进程的调试过程

接下来的内容：

- 修改已有的用于调试用户态程序的 Native Debug VSCode 插件，为其增加Qemu支持。一键启动 Qemu + GDB。
- 修改调试器插件已有的断点设置和断点触发处理函数，接入断点组管理模块
- 一个断点组管理模块要有哪些元素：断点组，断点映射到断点组，断点组映射到符号表，出口断点
- 出口断点是人工设置的（如果要自动设置的话，需要在断点组管理模块里支持基于地址的断点，并在可执行文件里找到ecall指令，我们没这么干）
- 断点 $ B_2 $ 对应的指令位置是自动检测的，检测方式是，每单步一次，就将当前的 PC 寄存器值和配置文件中提交的新断点组的 PC 寄存器地址范围做匹配，（因为页表切换后，PC寄存器值会有很大的变动，所以这么做可行），若匹配，则页表已经切换，断点组管理模块视为已经单步到断点 $ B_2 $ 对应的指令位置，开始加载新断点组。
- 出口断点 $ B_3 $ 不一定非得是页表切换指令的前一个指令，再前面一点也可以，只要保证单步的过程不被中断打断，出口断点触发之后一定会进行页表切换即可。好在页表切换之前，大部分操作系统都会关中断。关完中断之后的指令都可以当出口断点。因为出口断点是源代码断点，可能不能很精确地打到某一个指令（因为一行代码往往代表多个指令），所以我们设计的断点组切换方案对出口断点位置的要求比较宽松。
- 如果用户在调试过程中动态增加或删减了某个断点
- 限制：这种机制是同步的，所以异步的异常无法跟踪
- 每单步一次都判断pc范围，来确定有没有到达终点
- 用户在开始调试前需要通过人工分析被调试操作系统的代码并找出出口断点
- 为什么需要用单步来进行断点组的切换，怎么切换。自动不断地单步。当调试器检测到被调试os单步到下一个隔离环境后，他会切换到下一个断点组。在出口断点触发后，调试器会进行单步。

### B. 状态机，多进程

接下来的内容：

- 多进程调试的流程是什么样的，调试器需要增加什么代码
- 由于添加多进程调试功能，代码维护起来比较繁琐，所以我们用一个状态机来整理代码，把以前的所有的跨特权级调试功能和多进程调试功能都囊括进去。这个状态机包括哪些 states, events, actions，分别起什么用途
- 在状态机之外，还有钩子断点（下一个用户态进程的问题），起什么作用

### C. 硬件调试

接下来的内容：

- 基本思路：用 OpenOCD 替换 Qemu 的 GDBStub
- RISC-V 的 stepie 的问题